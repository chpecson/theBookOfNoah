# TUTS
  - bookmark: https://github.com/d3/d3-selection#joining-data
  - nextup:
    + https://github.com/d3/d3-scale
    + https://github.com/d3/d3-axis
    + https://github.com/d3/d3-color
    + https://github.com/d3/d3-transition
# D3 Links
  - [All d3 Modules API Reference](https://github.com/d3)
# Links
  - [SVG Blur effects](http://www.w3schools.com/svg/svg_fegaussianblur.asp)
  - [SVG Drop Shadows](http://www.w3schools.com/svg/svg_feoffset.asp)
  - [SVG Gradients](http://www.w3schools.com/svg/svg_grad_linear.asp)
	  + http://www.w3schools.com/svg/svg_grad_radial.asp
  - [SVG Examples](http://www.w3schools.com/svg/svg_examples.asp)


# Examples
  - mbstocks d3 in react: http://bl.ocks.org/milroc/d22bbf92231876505e5d

# Data visualization
  - data vis: the presentation of data in a graphical/pictoral format
  - visual perception: humans can distinguish differences in the following (pre-attentive) attributes with minimal effort
    1. length
    2. shape
    3. color
## bar charts
  - visual dimensions:
    1. length/count
    2. color
    3. category
## histogram
  - visual dimensions:
    1. bin size (range of intervals)
    2. length/count
    3. color
## scatterplot
  -  visual dimensions
    1. x & y positions
    2. color
    3. size
## network
  - purpose: how different data sets are related to eachother and between their nodes
  - visual dimensions
    1. node size
    2. node color
    3. ties size
    4. ties color
    5. spatialization
## tables
  - visual dimensions
    1. columns and rows
# SVG
  - svg supports complex shapes,
  - styling via css
  - tag based like html
  - viewport
    + The viewport is the visible section of an SVG. While an SVG can be as wide or as high as we wish, only a certain section of this image can be visible at a time.
    - The viewport is set through height and width attributes within the <svg>.
  - viewbox
    + specify that a given set of graphics stretch to fit a particular container element.
    + These values include four numbers separated by commas or spaces that should generally be set to the bounds of the viewport.
      - If we choose to not define a viewBox the image will not scale to match the bounds set by the viewport.
      - The min values represent from what point within the image the viewBox should start,
        1. min-x:
        2. min-y:
      - The width and height of our SVG establish the visible area (the viewport)
        3. width:
        4. height:
  - preserveAspectRatio, e.g. `preserveAspectRatio=“xMaxYMax meet”`
    + If the SVG viewBox and viewport do not have the same width to height ratio, preserveAspectRatio indicates whether or not to force uniform scaling.
    + align:  directs the viewBox's alignment within the viewport
      - https://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
      - https://www.w3.org/TR/SVG/images/coords/PreserveAspectRatio.svg
    + meetOrSlice: indicates how the aspect ratio is to be preserved.
      - meet: preserves the aspect ratio by scaling the viewBox to fit within the viewport as much as possible.
      - slice: attempts to fill the viewport with the viewBox and will then slice off any part of the image that does not fit inside the viewport after this scaling.
      - none: no preserved aspect ratio and a potentially distorted image.
    + common values
      - `xMinYMax meet`:
        + aligning the bottom left corner of the viewBox to the bottom left corner of the viewport
        + meet is ensuring the image is scaling to fit inside the viewport as much as possible.
      - `xMinYMin meet`:
        +
## basics
  - create a canvas
    ```
      <svg style='background-color:black' height='100' width='100'>
        <text x='0' y='20' fill='red'>
          This is SVG Text
        </text>
      </svg>
    ```
# d3 basics
  - manipulate html documents based on data
  - display data using html, svg, and css
	- uses css like selectors
	- use css/js for styling
	- easy parse data from text, json, html, csv, tsv
	- data binding: retrieve data and bind it to a function
	- has a physics engine
	- comes with click & drag behaviors
## definitions
  - binding data: bind (connect) data to dom nodes
  + take an array of numbers and bind them to an html table, when the array updates the html table updates
  + data: text, json, html, csv, tsv
## quickies
  - most callback functions should accept arguments (d, i, g) => data, index, group, with 'this' being the current node
### utility functions
  - get the max number: `d3.max(array)`
### selecting: all return selections
  - select the first paragraph: `d3.select('p')`
  - select all paragraphs: `d3.selectAll('p')`
  - select a node: `d3.select(this)`
  - select all child paragraphs: `d3.select(this).select('p')`
  - select all previous elements: `d3.selectAll("p").select(() => this.previousElementSibling);`
  - select only the even: `d3.selectAll("tr").filter(":nth-child(even)");`
### changing attributes, properties and styles: all operate on selections
  - update an attribute: ` selection.attr('name'[, value|function])`
  - assign both classes foo and bar to selection: `selection.classed("foo bar", true);`
    + you can pass a function, if its return is truthy, that element is given the class
  - updating style of element: `selection.style(name[, value[, priority]])`
### changing text
  - set the text content: `selection.text([value])`
  - set the inner html: `selection.html([value])`
    + SVG elements and other non-HTML elements do not support the innerHTML property
### Appending|inserting|removing|etc nodes
  - append a new child element: `d3.selectAll("p").append("div");`
  - insert an element before this one: `selection.insert(type, before)`
  - remove elements: `selection.remove()`
  - other functions:
    + sort, order, raise, lower, creator
### Joining Data
  -
### changing
  - change text of an element: `d3.select('p').text('some text')`
    + you can insert html elements
  - change the style of an element: `d3.select('#piechart').style('color', 'red');`
  - change the style of the second element: `d3.select('#piechart .item:nth-child(2n)').style('color', 'red');`
  - change the style of every second element: `d3.selectAll('#piechart .item:nth-child(2n)').style('color', 'red');`
  - change the style of every odd element: `d3.selectAll('#piechart .item:nth-child(odd)').style('color', 'red');`
    + nth-child(2n+1)
  - change the class name of an element: `d3.select('#piechart .unordered').classed('items', true);`
    + this adds the value to the existing classes of the element
    + set to false to remove
  - change specific attribute: `d3.select('h1').attr('class', 'my-new-class')`;
    + this replaces whatever value it had before
  - modify properties not addressable via style|attr functions
    + form field's text value
    + checkbox's check value
    + `selection.property(name[, value])`
### adding
  - append a div with text: `d3.select('p').append('div').html('some text')`
  - insert (append) a li with text: `d3.select('#piechart .unordered').insert('li').html('new item inserted');`
  - insert a li with text as the third item: `d3.select('#piechart .unordered').insert('li', ':nth-child(3n)').html('new item inserted');`
### removing
  - remove a specific element: `d3.select('#some-element').remove()`
  - remove a the third element: `d3.select('.items:nth-child(3n)').remove()`
### binding data
  - the following only modify EXISTING DOM NODES,
    + if the dom nodes dont exist, nothing happens
    + if only some of the dom nodes exist, only those are updated
      - insert the value of each item in an array into existing DOM nodes
        ```
          d3.selectAll(`#${this.props.id} .array .item`) // select items
            .data(this.props.data.array) // bind data
            .text((d) => d); // map array#index to dom-node#index
        ```
      - use the value of each item in array to set the style of each element
        ```
          d3.selectAll(`#${this.props.id} .array .item`)
            .data(this.props.data.array)
            .style('font-size', (d) => `${d}px`);
        ```
  - add new DOM nodes as required by data
    ```
      // bind data to element, and modify existing elements
      const arrayItems = d3.select(`#${this.props.id} .array`)
        .selectAll('.item')
        .data(this.props.data.array)
        .text((d) => d)
        .style('font-size', (d) => `${d}px`);
      // add additional dom nodes for items in data, and modify new elements
      arrayItems
        .enter()
        .append('li')
        .text((d) => d)
        .style('font-size', (d) => `${d}px`);
      // remove extra dom nodes, if any
      arrayItems
        .exit()
        .remove();
    ```
## scales
  - map an input domain (e.g. 0 to 10000) to an output range (e.g. 0 to 100)
    + the output range should map to the dimensions of the svg viewport
    + input domain: [0, 1000] : is the lowest and highest points in the data
    + output range: [0, 100] : range of possible values commonly used as display values in pixels
### creating scales:
  - https://github.com/d3/d3-scale/blob/master/README.md#continuous-scales
    + you need to confirm everythign below with the d4 version
  - d3.scale.TYPEOFSCALE
  - linear
    + const linear = d3.scale.linear();
      - linear.domain([0, 1000]);
      - linear.range([0, 10]);
      - scale(20) // returns a number mapped to the output range
  - quantitative: for continuous input domains, like numbers
    + linear: y can be expressed as a linear function of x
    + identity: where the domain and range are identical
    + power: exponential transform is applied to input domain, supports negative values
    + log: log transform is applied to the input domain
    + quantize: divided into segments based on the number of values in the output range
    + threshold: map subsets of domain to discreet values
  - ordinal: for discreet input domains, like categories/words
  - time: for time
## broad steps
	- css
		+ set your axis path & line
			```
        fill:none;
  			stroke: color;
  			stroke-width: 1;
  			shape-rendering: cripsEdges;
      ```
	- bar chart
    1. define your margins
		2. define your color scale
		3. grab your chart placeholder and append an svg element
		4. inside the svg element append a group
		5. grab your data
		6. format your data
		7. setup your scales
		8. pass your data to ordinal/linear/etc scales and define the range
		9. setup your bars
	- line chart
		1. define your margins
		2. define your scales
		3. define your axises
		4. define your line
		5. add the svg canvas
		6. grab the data from csv
		7. pass your data through the scales
		8. add the line to the svg
		9. add your axises to the svg
## boilerplate sections {
  - canvas margins:
		+ var margin={top:N, right:N, bottm:N, left:N}
		  - add margins around the actual canvas
  - canvas dimensions:
	  + var width = 600 - margin.left - margin right
	  + var height = 600 - margin.top - margin.bottom
			- the actual dimensions of the canvas (and thus the graph)
## d3 requests:
  - use the following methods to request data
  ```
		.text()
		.json()
		.xml()
		.html()
		.csv()
		.tsv()
  ```
    + e.g.
      ```
    		d3.csv("path/to/csv.csv", function(error,data){
    			data.forEach(function(d){
    				do stuff;
    			})
    		})
      ```
## adding a svg canvas
  ```
		var svg = d3.select('somediv')
			.append('svg')
				.attr({
					'width':width + margin.left + margin.right,
					'height':height + margin.top + margon.bottom
				})
			.append('g')
				.attr({
					'transform': "translate(" + margin.left + "," + margin.top + ")")
				})
  ```


# d3 scales
	- allow you to fit your data into the canvas no matter how many data points
	- allow you to map an input domain to an output range
		+ thus you can be sure your input domain(data) will always fit your output range(graph) succinctly based on the dimensions of the canvas
  - definitions
		+ domain: all possible input values that need to be mapped to the range
		+ range: specifies the range of the canvas, and the order in which the data should be laid out
			- range([height, 0])
        + place the larger values at top of the screen and the lower values at the bottom of the screen
## scale types
	- quantitative scales: for continuous input domains,
		+ numbers, un ordered lists,
	- ordinal scales: for discrete input domains, eg.. names/categories
    + ordered lists
      - the order of the information is relevant
      - this is how you add unlimited values and allow them to fit inside any size canvas
  - time scales: for time domains
### ordinal scales: good for categories
	- xScale = d3.scale.ordinal(x)
    + returns a new ordinal scale with an empty domain and empty range
		+ x = input domain, will return the corresponding value in the output range
		 - e.g. xScale(i)
	  - xScale.domain([your values])
      + the first element in values is mapped to the first element in the output range
      + the domain values are stored as an associated array mapping value to index
			+ to retrieve a value, you send in an index, and you receive its value
		- xScale.range([your values])
			sets the output range to the specified array of values
			the first element in the domain, is mapped to the first element in values
			you can instead 'use' rangePoints or rangeBands
		.rangePoints([min,max],padding)
			interval = min & max of the output range, maps the domain to equally in this range
			padding = set it from 0 to 1, to offset the first and last bars from the edges
		.rangeRoundPoints([min, max], padding)
			interval = see above
			padding = see above
			the difference is that the output range will be integers, and not decimals
		.rangeBands([min,max],padding, outerpadding)
			interval = see above
			padding = space between bars
			outer padding = space between outer bars and chart
		.rangeRoundBands([min,max], padding, outer padding)
			everything is same as above
			only it ensure the intervals are integers and not decimals

		xScale.domain() returns the input domain
		yScale.range() returns the output range

	color categories
		category10() = 10 colors
		category20() = 20 colors
		category20b()
		category20c()
		e.g.
			var colors = d3.scale.category10();


	//linear scales: good for continuous numbers
	yScale = d3.scale.linear(x)
		give a value x in the input domain, returns the corresponding value in the output range
			e.g. yScale(x) : 'use' it like a function to find its place in the scale
		.domain([numbers])
			pass in all of your data points, 2 or more numbers
		.range([values])
			maps the input domain to this output range

	//send your scales to the axis command, to display the axis on the chart
	xAxis = d3.svg.axis()
		creates and returns an empty axis
		xAxis(xScale)
			sets the scale and returns the axis
		.orient('type')
			type = top, bottom, left, right
		.ticks([arguments])
			linear scale: specify a number, e.g. 20
		.tickValues([val1, val2, valX])
			gives a value to each tick

	        /**
         *tick formats
         *"top" - horizontal axis with ticks above the domain path
         *"bottom" - horizontal axis with ticks below the domain path
         *"left" - vertical axis with ticks to the left of the domain path
         *"right" - vertical axis with ticks to the right of the domain path
         */
}

d3 time {
	var parseDate = d3.time.format("your-format-here").parse;
		format("%Y-%m-%d %H:%M:%S")
			generic MySQL ‘YYYY-MM-DD HH:MM:SS’ TIMESTAMP


	var data.someDate = parseDate(data.someData);

	parseDate is now a function base on d3.time
	you can pass data to the function, and it will be formatted so that d3 can recognize it
	formats
		%a - abbreviated weekday name.
		%A - full weekday name.
		%b - abbreviated month name.
		%B - full month name.
		%c - date and time, as “%a %b %e %H:%M:%S %Y”.
		%d - zero-padded day of the month as a decimal number [01,31].
		%e - space-padded day of the month as a decimal number [ 1,31].
		%H - hour (24-hour clock) as a decimal number [00,23].
		%I - hour (12-hour clock) as a decimal number [01,12].
		%j - day of the year as a decimal number [001,366].
		%m - month as a decimal number [01,12].
		%M - minute as a decimal number [00,59].
		%p - either AM or PM.
		%S - second as a decimal number [00,61].
		%U - week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
		%w - weekday as a decimal number [0(Sunday),6].
		%W - week number of the year (Monday as the first day of the week) as a decimal number [00,53].
		%x - date, as “%m/%d/%y”.
		%X - time, as “%H:%M:%S”.
		%y - year without century as a decimal number [00,99].
		%Y - year with century as a decimal number.
		%Z - time zone offset, such as “-0700”.
		There is also a a literal “%” character that can be presented by using double % signs.
}

d3 axis {
	https://github.com/mbostock/d3/wiki/SVG-Axes
	d3.svg.axis().scale(yourScale)
		.orient('blah')
			top/bottom/left/right
			where to place the tick marks relevant to the axis?
		.ticks(N)
			# of ticks
			or a function
		.tickValues(n1,n2,etc)
			specify specific values for the tick
		.tickSize(inner, outer)
		.innerTickSize(size)
			specify only the inner tick size
		.outerTickSize(size)
			specify only the outer tickSize
		.tickPadding(size)
			defaults to 3px
		.tickFormat(format)

 	displays reference lines for scales automatically
}

d3 line {
	d3.svg.line()
		.x(function(d){return xScale(d.xvalue)})
			//set the x value for the current data point
		.y(function(d){return yScale(d.yvalue)})
			//set the y value for the current data point
		.interpolate('blah')
			linear - piecewise linear segments, as in a polyline.
			linear-closed - close the linear segments to form a polygon.
			step - alternate between horizontal and vertical segments, as in a step function.
			step-before - alternate between vertical and horizontal segments, as in a step function.
			step-after - alternate between horizontal and vertical segments, as in a step function.
			basis - a B-spline, with control point duplication on the ends.
			basis-open - an open B-spline; may not intersect the start or end.
			basis-closed - a closed B-spline, as in a loop.
			bundle - equivalent to basis, except the tension parameter is used to straighten the spline.
			cardinal - a Cardinal spline, with control point duplication on the ends.
			cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
			cardinal-closed - a closed Cardinal spline, as in a loop.
			monotone - cubic interpolation that preserves monotonicity in y.
}

d3 arcs (half circle charts){

}
d3 functions{
	d3.extent(values)
		returns an array with the lowest and highest values
		d3.extent(data, function (d){return d.somedata})

	d3.max(values)
		returns the largest value
			d3.max(data, function(d){ return d.somedata})
	d3.format
		https://github.com/mbostock/d3/wiki/Formatting#d3_format
}
selectors {
	d3.select(selector)
		selects the first element that matches the selector string

	d3.selectAll(selector)
		selects all elements thta matches the selector

	selects: regular css
		#someid .childclasses
		.class:nth-child(5) #select the 5th element
			:nth-child(odd)
				even
				n+3
				3n
}

commands basic {

	inserting new things
		.text('insert this')
			inserts this into the selected element

		.html('<b>random bold element</b>')
			inserts html into the selected element

		.append('div')
			inserts a new element as the last child of the selected element

		.insert('div' ':nth-child(3)');
			insert a new div as the 3rd child in the selected element

	removing items
		.remove()
			remove the selected element

	modifying items
		.attr('class', 'value')
			provide an attribute and a value
			this will replace the current value with the new value

		.classed('newclass', 'true')
			adds  a new class, without removing the current class
				true = add the class
				false = remove the class

		.classed({
			'class1': true
			'class2': false
		})
			send in multipel classes to turn on/off

	css
		.style({
			'key': 'value'
		})
			provide css key value pairs,
			can be used to automate things

}

commands data {
	d3.selectAll('.items.')
		.data([blah1,blah2])

			takes an array of elements,
			and applies the first item in the array to the first item selected
			and the second item in the array to the second item selected

		.data(myVar)
		.style('background', myStyles[0])
			can hold the array as a variable and send the var in
			then use specific items in the array


		.data(myStyles)
		.style('background', function(d) {
			return d[0]
			[or]
			return d
		})
			 d = myStyles, 0 takes the first element
			 if you dont pass it an index, each item in the myStyles
			 will be used to style the matchign index in the selection

		.data(myStyles)
		.style({
			'color':'white',
			'background':function(d){
				return d;
			}
		})
			change multiple values to the style method
			and still use the myStyles array

		.data(myStyles)
		.style({
			'color':'white',
			'background':function(d){
				return d.color;
			},
			'width':function(d){
				return d.width + 'px';
			}
		})
			myStyes = an object
			you can specify which property of the object to use


}

commands subselector {
	use the .enter() command to create a placeholder
	for selecting subselections of other selections

	d3.selectAll('#main') #select id main
		.selectAll('div') #create a placeholder element
		.data(myStyles) #bind .data to the placeholder element and pass in your object styles
		.enter() #eneter the placeholder element
		.append('div') #replace the placeholder with the actual element
		.classed('item', true) #toggle the class item to true
		.text(function(d){ #add d.name property as the text
			return d.name;
		})
		.style({
			'color':'white',
			'background':function(d){
				return d.color; #add d.color style to the text color
			},
			'width':function(d){
				return d.width +'px'; #add d.width as the width
			}

		})
}


d3 events {
	'use' the .on method
	.on('mouseover',function(d){
		d3.select(this)
			.style('opacity',0.5);
	})
	.on('mouseout',function(d){
		d3.select(this)
			.style('opacity',1);
	})
}

d3 transitions {
 review: http://www.lynda.com/D3js-tutorials/Using-transitions-animations/162449/185065-4.html
	.transition()
	.delay(500) //in milliseconds
	.delay(function(d,i){
		return i*20
	})
	.duration(800) //in milliseconds
	.ease('elastic')

}


d3 layouts {
	https://github.com/mbostock/d3/wiki/layouts

	e.g. pie charts, bar charts, etc.
	provides utilities to convert your data into a layout
}

d3 catagorical colors {
	utility function that provides base colors for your charts

	https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors
}


transitions {

	ease types
		*linear
		*quad
		*cubic
		*sin
		*exp
		*circle
		*elastic
		*back
		*bounce

}

d3 lines {

	interpolate options
		*linear - piecewise linear segments, as in a polyline.
		*linear-closed - close the linear segments to form a polygon.
		*step-before - alternate between vertical and horizontal segments, as in a step function.
		*step-after - alternate between horizontal and vertical segments, as in a step function.
		*basis - a B-spline, with control point duplication on the ends.
		*basis-open - an open B-spline; may not intersect the start or end.
		*basis-closed - a closed B-spline, as in a loop.
		*bundle - equivalent to basis, except the tension parameter is used to straighten the spline.
		*cardinal - a Cardinal spline, with control point duplication on the ends.
		*cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
		*cardinal-closed - a closed Cardinal spline, as in a loop.
		*monotone - cubic interpolation that preserves monotonicity in y.

}

svg<?php

background {
	SVG: scalable vector graphics
		used to define vector graphics for the web, including xml
		every element and attribute in svg can be animated

}

structure {
	all attributes can be set by css unless otherwise noted

	reference: http://www.w3schools.com/svg/svg_reference.asp

	<svg> blah </svg>
		container for SVG elements
		width="#" width of container
		height="#" height of container

	<g> </g>
		container of other elements


	shapes
		text:
			<text> blah </text>
				x="#"
				y="#"
				fill="color"
				transform="blah"

				text: with tspan elements to put text on different lines
					<text x="#" y="#" fill="color">
						<tspan x="#" y="#"> hello </tspan>
						<tspan x="#" y="#"> buhby </tspan>
					</text>

				text: as link with an A element
					<svg height="30" width="200" xmlns:xlink="http://www.w3.org/1999/xlink">
					  <a xlink:href="http://www.w3schools.com/svg/" target="_blank">
					    <text x="0" y="15" fill="red">I love SVG!</text>
					  </a>
					</svg>

		lines:
			<line />
				x1="#" start of line on x axis
				x2="#" end of line on x axis
				y1="#" start of line on y axis
				y2="#" end of line on y axis

		rectangle:
			<rect />
				width="#"
				height="#"
				x="#" positive moves to the right
				y="#" positive moves down
				ry="#" round the radius of corners
				rx="#" round the radius of corners

		circle:
			<circle />
				cx="#" center of circle on x
				cy="#" center of circle on y
				r="#" radius of circle

		ellipse: like a circle but has different radius for x and y
			<ellipse />
				cx="#"
				cy="#"
				rx="#" horizontal radius
				ry="#" vertical radius

		polygon: poly = many, gon = angles, e.g. a triangle
			<polygon />
				points="#,# #,# #,# etc."
					#,# = x & y corrdinate of each corner of the polygon

		polyline: any shape that consists of only straight lines
			<polyline />
				points="#,# #,# #,# etc"

		path: define a path, i.e a drawing
			<path />
				d="M150 0 L75 200 L225 200 Z"
					the first point opens the path
					the last letter Z closes the path
				M = move to
				L = line to
				H = horizontal line to
				V = vertical line to
				C - curve to
				S = smooth to
				Q = quadratic bezier curve
				T - smooth quadratic bezier curve to
				A = elliptical arc
				Z = close path
					capital letters = absolutely positioned
					lower case letters = relatively positioned



	common atributes
		stroke="color" color of line, text, or outline of an element
		stroke-width="#" thickness of line, text, or outline of an element
		stroke-linecap="blah" different types of endings to an open path
			butt, round, square
		stroke-dasharray="#,#,#,#,etc" created dashed lines


		fill="color" color of shape
		fill-rule="blah"
			nonzero, evenodd


}


SVG filters {
	<feBlend> - filter for combining images
	<feColorMatrix> - filter for color transforms
	<feComponentTransfer>
	<feComposite>
	<feConvolveMatrix>
	<feDiffuseLighting>
	<feDisplacementMap>
	<feFlood>
	<feGaussianBlur>
	<feImage>
	<feMerge>
	<feMorphology>
	<feOffset> - filter for drop shadows
	<feSpecularLighting>
	<feTile>
	<feTurbulence>
	<feDistantLight> - filter for lighting
	<fePointLight> - filter for lighting
	<feSpotLight> - filter for lighting
}
