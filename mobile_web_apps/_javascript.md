# https://developers.google.com/web/fundamentals/getting-started/primers/promises

# Need to file
  - never dev on the local file system when requiring access to external resources as sometimes they wont load

# Roadmap
  1. google web fundamentals
  2. topics
  2. es6 and ES7
  3. html
  4. css
  4. [yslow](http://yslow.org/)
  5. [timeline tool](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool)
  6. [web font performance](https://www.igvita.com/2014/01/31/optimizing-web-font-rendering-performance/)
  7. [server configs](https://github.com/h5bp/server-configs)
  8. [cache control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)
  9. [master dev tools](http://discover-devtools.codeschool.com/)
  10. [build better mobile user experience](https://www.thinkwithgoogle.com/topics/create-better-mobile-user-experience.html)
  11. [web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
  12. [progress & activity](https://material.io/guidelines/components/progress-activity.html)
  13. [BEM: Block Element Modifier](https://en.bem.info/)
  14. [style invalidation in blink](https://docs.google.com/document/d/1vEW86DaeVs4uQzNFI5R-_xS9TcS1Cs_EUsHRSgCHGu8/edit)
  15. [flip principle](https://aerotwist.com/blog/flip-your-animations/)
  16. [es6 in depth articles](https://hacks.mozilla.org/2015/06/es6-in-depth-collections/)
## other things to touch
  - [service workers](https://jakearchibald.github.io/isserviceworkerready/index.html)
  - [image src-set for responsiveness](https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-srcset/)
  - https://jakearchibald.com/2013/progressive-enhancement-is-faster/
  - [streams](https://jakearchibald.com/2016/streams-ftw/#streams-the-fetch-api)
  - [web components in polymer](https://www.polymer-project.org/1.0/blog/es6)
  - [font face observer](https://github.com/bramstein/fontfaceobserver)
  - [web font loader](https://github.com/typekit/webfontloader)
  - [font optimization](https://www.zachleat.com/web/web-font-data-uris/)
  - [real user monitoring: RUM](https://en.wikipedia.org/wiki/Real_user_monitoring)
  - [lighthouse](https://developers.google.com/web/tools/lighthouse/)
  - [create react app1](https://github.com/facebookincubator/create-react-app)
  - [create react app scripts](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment)
# NEXT UP
  - https://medium.freecodecamp.com/ivy-league-free-online-courses-a0d7ae675869#.dzefyfnlg
  - https://developer.mozilla.org/en-US/docs/Web/API/ValidityState
  - https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms_in_HTML#Constraint_Validation_API
  - https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/My_first_HTML_form
  - https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Sending_and_retrieving_form_data
  - [push notifications](https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web)
  - [run through all articles](https://developers.google.com/web/updates/2017)
  - [custom site search view google](https://cse.google.com/cse/)
  - [remote debugging](https://jakearchibald.github.io/isserviceworkerready/index.html)
  - [javascript engine](https://www.quora.com/How-does-a-JavaScript-engine-work)
  - [how browsers work](http://taligarsiel.com/Projects/howbrowserswork1.htm)
# need to research
  -  feature detection: `if(document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Extensibility','1.1'))`
  - buffers
  - font loading api
  - [latency vs bandwidth](https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/)
  - react debounce input handler
# tools
  - [google mobile friendly test](https://search.google.com/search-console/mobile-friendly)
  - [mozilla SSL configuration](https://mozilla.github.io/server-side-tls/ssl-config-generator/)
  - [github pages](https://pages.github.com/)
  - [manage all service workers](chrome://inspect/#service-workers)
  - [page speed insights](https://developers.google.com/speed/pagespeed/insights/)
  - [apache/nginx pagespeed optimize tool](https://developers.google.com/speed/pagespeed/module/)
  - [css triggers](https://csstriggers.com/)
  - [JIT in action](http://mrale.ph/irhydra/2/)
  - [FastDOM](https://github.com/wilsonpage/fastdom)
  - github pages vs surg.sh
    - gh-pages plugin: This will allow us to publish to the gh-pages branch on GitHub straight from within the terminal:
  - [android emulator](https://developer.android.com/studio/run/emulator.html#netspeed)
  - [webpage speed test](https://developers.google.com/web/fundamentals/performance/poor-connectivity/)
  - [free web debugging proxy](http://www.telerik.com/fiddler)
  - [augmented traffic control](http://facebook.github.io/augmented-traffic-control/)
  - [javascript AST visualizer](http://resources.jointjs.com/demos/javascript-ast)

# NEED to finish
  - https://classroom.udacity.com/nanodegrees/nd802/parts/8021345403/modules/550593026975460/lessons/5972243496/concepts/61045985370923
  - MUST FUCKING DO
    + https://developers.google.com/web/fundamentals/
    + https://codelabs.developers.google.com/?cat=Web
  - need to research
    + web workers
    + [watchman](https://facebook.github.io/watchman/docs/install.html
    https://developers.google.com/web/)

    + around the web:
      - [Google Developer Training](https://developers.google.com/training/)
      - [SEO](https://developers.google.com/webmasters/googleforwebmasters/)
      - https://blog.minio.io/microstorage-for-microservices-70231db026a8#.7h6uid196
      - http://blog.webkid.io/react-ui-libraries/
      - https://www.youtube.com/watch?v=O1YP8QP9gLA&feature=youtu.be
      - https://www.youtube.com/watch?v=Yy7gFgETp0o
      - https://www.youtube.com/watch?utm_campaign=Fullstack%2BReact&utm_medium=email&utm_source=Fullstack_React_37&v=aV1271hd9ew
      - https://github.com/acdlite/recompose
      - https://hashnode.com/post/the-one-thing-that-no-one-properly-explains-about-react-why-virtual-dom-cisczhfj41bmssp53mvfwmgrq?utm_campaign=Fullstack+React
      - https://en.wikipedia.org/wiki/Comet_(programming)#Hidden_IFrame3
      - http://jankfree.org/
    + project 5
      - https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
      - https://developers.google.com/web/tools/lighthouse/
      - https://jakearchibald.com/2014/offline-cookbook/
      - https://developers.google.com/web/progressive-web-apps/
      - https://github.com/GoogleChrome/lighthouse
      - http://node-machine.org/machinepacks

    + project 3
      - http://webaim.org/standards/wcag/checklist
      - https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
      - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
      - https://developers.google.com/web/updates/2016/03/focus-start-point?hl=en
      - http://webaim.org/techniques/skipnav/
      - https://developers.google.com/web/updates/2016/03/focus-start-point?hl=en
      - https://www.w3.org/TR/wai-aria-practices-1.1/
      - https://www.w3.org/TR/wai-aria-practices/
      - https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn/related?hl=en
      - https://www.w3.org/TR/wai-aria-1.1/#terms
      - https://www.w3.org/TR/wai-aria-1.1/#namefromcontent
      - https://www.w3.org/TR/wai-aria-1.1/#abstract_roles
      - https://www.w3.org/TR/wai-aria-1.1/#widget_roles
      - https://www.w3.org/TR/wai-aria-1.1/#document_structure_roles
      - https://www.w3.org/TR/wai-aria-1.1/#landmark_roles
      - https://www.w3.org/TR/wai-aria-1.1/#live_region_roles
      - https://www.w3.org/TR/wai-aria-1.1/#role_definitions
      - https://www.w3.org/TR/wai-aria-practices-1.1/
      - https://www.w3.org/TR/html-aria/
      - https://www.w3.org/TR/wai-aria-1.1/#attrs_relationships
      - https://www.w3.org/TR/wai-aria/states_and_properties#attrs_relationships
      - https://www.w3.org/TR/wai-aria/states_and_properties#state_prop_def
      - http://webaim.org/techniques/css/invisiblecontent/
      - http://heydonworks.com/practical_aria_examples/
      - https://developers.google.com/web/fundamentals/accessibility/semantics-builtin/the-accessibility-tree
      - https://material.google.com/usability/accessibility.html
      - http://webaim.org/resources/contrastchecker/
      - http://wave.webaim.org/
      - https://chrome.google.com/webstore/detail/nocoffee/jjeeggmbnhckmgdhmgdckeigabjfbddl/related?hl=en-US
      - https://chrome.google.com/webstore/detail/high-contrast/djcfdncoelnlbldjfhinnjlhdjlikmph/related?hl=en
      - https://chrome.google.com/webstore/detail/wave-evaluation-tool/jbbplnpkjmmeebjpijfedlgcdilocofh
      - https://chrome.google.com/webstore/detail/accessibility-developer-t/fpkknkljclfencbdbgkenhalefipecmb?hl=en
      - http://a11yproject.com/patterns/
      - https://codepen.io/chrisdpratt/pen/dmyne
    + project 2
      - https://www.html5rocks.com/en/tutorials/es6/promises/
      - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
      - https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState
      - https://ponyfoo.com/articles/es6
      - http://jsforallof.us/2015/02/12/utilising-node-and-npm-for-front-end-development-workflow/
      - https://bocoup.com/weblog/a-facade-for-tooling-with-npm-scripts
      - https://developers.google.com/web/tools/chrome-devtools/network-performance/network-conditions?hl=en
      - https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequests
      - https://promisesaplus.com/
      - https://github.com/petkaantonov/bluebird
      - https://developers.google.com/web/fundamentals/getting-started/primers/service-workers
      - https://davidwalsh.name/fetch
      - https://davidwalsh.name/javascript-battery-api
      - https://davidwalsh.name/battery-api
      - https://developers.google.com/web/updates/2015/03/introduction-to-fetch
      - https://github.com/github/fetch
      - https://jakearchibald.com/2014/resolve-not-opposite-of-reject/
      - https://davidwalsh.name/promises
      - https://github.com/HubSpot/tether
      - https://reactstrap.github.io/
      - https://github.com/brillout/awesome-react-components#ui-frameworks
      - http://amazeui.org/react/
      - https://ant.design/
      - http://nikgraf.github.io/belle/#/?_k=4ljm7x
      - https://grommet.github.io/
      - http://elemental-ui.com/
      - https://material.uplabs.com/
      - http://www.material-ui.com/#/get-started/usage
      - https://react.foundation/
      - https://jakearchibald.github.io/isserviceworkerready/
      - https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers
      - https://developer.mozilla.org/en-US/docs/Web/API/Request
      - https://developer.mozilla.org/en-US/docs/Web/API/response
      - https://serviceworke.rs/
      - https://dexecure.com/
      - https://blog.dexecure.com/beyond-offline-other-interesting-use-cases-for-service-workers-2/
      - https://developer.mozilla.org/en-US/docs/Web/API
      - https://developer.mozilla.org/en-US/docs/Web/API/Cache
      - https://developers.google.com/web/tools/chrome-devtools/manage-data/local-storage
      - https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#gloss_object_store
      - https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-srcset/
    + project 1
      - https://www.html5rocks.com/en/tutorials/forms/constraintvalidation/
      - http://www.html5rocks.com/en/tutorials/geolocation/trip_meter/
      - https://developers.google.com/web/updates/2015/06/checkout-faster-with-autofill?hl=en
      - http://mlitzinger.com/blog/password-validator-js/
      - https://css-tricks.com/html5-progress-element/
  - completed
    + project 1
    	- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type
    	- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist
    	- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label
    	- https://www.tjvantoll.com/2013/04/15/list-of-pseudo-elements-to-style-form-controls/#input_date
    	- http://www.wufoo.com/html5/

# TIPS, TRICKS, BEST PRACTICES
## Best Practices
  - generally a good practice to have some throttling when testing sites. It'll help you see your sites performance from your users perspectives.
  - wrap next level JS in feature detection logic 'for' progressive enhancment `if (this.next.level.shit) run it`
  - javascript doesnt have private methods,  but methods that should be private should be indicated with an underscore in the name if they are only called by a specific object
  - OFFLINE FIRST (all child of window less otherwise stated)
    + online first: we try the network first, if it doesnt, we show some fallback content (or 404 page)
    + offline first:
        1. full content: deliver page header + content from cache, then update via network request
          .update cache on SW install
          .strategy for unobtrusive app updates
          .get the user onto latest version
          .continually update cache of posts
          .selectively cache everything you want available offline (e.g. images, posts, etc.)
        2. header first: deliver page header from cache, attempt to retrieve content via network request, then fall back to cached content on device
    + anything in this file stemming from window... (e.g. document, navigator, etc.) is happening in a page/document
    + cache photos/media instead of storing them in db.
      db: read data > convert to blob > store it. loses streaming capabilities
      cache: request data > streams back > and can display it as it arrives (i.e. piece by piece)
  - browser requests
    1. request > http cache (found?) return page
    2. else > go to internet > retrieve html>
    3. other stuff needed ? > request css & javascript
  - Search Fields
    1. auto-completing queries, correct misspellings, suggest related queries
    2. place filters above search results and always display # of results
  - Ecommerce
    1. allow users to purchase as guests
## TRICKS
  - check if someVar is an Array (or anything, e.g. Number, or Object)
      `if(someVar && Array === someVar.constructor)``
      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor
  - check if variable exists
    `if (bar !== null) && ((typeof bar === "object") || (typeof bar === "function")));`
  - specifically check for null
		`if(variable === null && typeof variable === "object")`
  - convert function arguments to array
    ```
      function () {
          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
            var args = Array.prototype.slice.call(arguments);
      }
    ```
  - check if properties exists and is owned by object
  	`	if (thisObject.hasOwnProperty('thisPropertyName')) return true;`
  - check if property exist and is owned by object or the objects prototype
  		`(if 'thisPropertyName' in thisObject) return true;`
# TERMINOLOGY
  - web sockets: a persistent connection to a server
  - sourcemaps: tell the browser to convert line and column offsets 'for' exceptions thrown in the bundle file back into the offsets and filenames of the original sources.
  - transpilation: ES6 > Babel > ES5
  - metaprogrammaning: all about the underlying mechanics of the language, rather than “high level” data modelling or business logic. If programming can be described as “making programs”, meta-programming could be described as “making programs making programs”
    + Code Generation, aka eval & friends -
    + Reflection - finding out about and adjusting the structure and semantics of your application
      + Functions:
        - Function#name
        - Function#length
        - Function#bind
        - Function#call
        - Function#apply.
      + Object.getOwnProperties (As an aside,
    + Introspection: Reflection tools that don’t alter code, but instead gather information about it are often called

# TOPICS
## caching
  - choosing the optimal `Cache-Control` header policy
    1. response not resusable ? use `no-store`
    2. browser needs to revalidate the resource each time ? use `no-cache`
    3. cacheable by intermediate caches?
      - yes: use `public`
      - no: use `private`
    4. maximum cache life time ? set `max-age=#` to # of seconds
    5. add `Etag` header
  - add a fingerprint to files in order to extend cache times and invalidate cache responses
    1. e.g. turn blah.css to blah.timestamp.css
    2. else embed a blah.css?v=timestamp inside of content
### headers
  1. `Etag`: validation token to determine if a file has changed
    - if a browser has an asset that is expired, it can make a request to the server for the assets ETag
      1. if the servers etag === browser etag, it will continue to use the browser version from cache
      2. if they are different, it will send an additional request for the updated resource
    - the client automatically provides the ETag token in the "If-None-Match" HTTP request header.
      1. The server checks the token against the current resource. If the token hasn't changed, the server returns a "304 Not Modified" response
        - which tells the browser that the response it has in cache hasn't changed
        - updated `Cache-Control` header to be applied to the browser's version of the resource, e.g. to be renewed for another 120 seconds.
  2. `Cache-Control`: control who can cache the response, under which conditions, and for how long
    - you can set multiple directives in `Cache-Control`
      1. `Cache-Control: private, max-age=600`
    - `Cache-Control: max-age=120`: cache for 120 seconds
    - `Cache-control: no-cache`: the returned response cant be used to satisfy a subsequent request to the same URL without first checking with the server to see if the response has changed (i.e. via `Etag` header)
    - `Cache-Control: no-store`: disallows the browser and all intermediate caches from storing any version of the returned response, e.g. for private or personal ifnormation like banking stuff
    - `Cache-Control: public`: this can be cached
      1. even if it has http authentication data associated with it
      2. even if the http response status code isnt normally cacheable
    - `Cache-Control: private `: the browser can cache it, but not intermediate caches
      1. this is usually for resources that are meant for a single user
    - `Cache-Control: max-age=#`: sets the max age for this resource to # in seconds

  3. `Expires`:
## performance
  - javascript is not run on the CPU, there is a javascript VM that takes your code and runs it on the CPU
    - it is a black box, you must be sure you've written your code in a way that does not hinder the VM
  - types of tools
    - caching
    - network analyzes: delivery of assets, combining assets, etc
      1. yslow, pagespeed, devtools
    - profilers: measure runtime execution of scripts during life of app
      1. yui profiler, pagespeed, devtools
    - cdns
# Measuring performance
  1. lighthouse: identify obvious CRP optimization opportunities
  2. RUM: real user monitoring: instrument your code with the *navigation timing API* to monitor how your app performs out in the wild
  - navigation timing API
    1. domloading: this is the starting timestamp of the entire process, the browser is about to start parsing the first received bytes of the HTML document.
    2. dominteractive: marks the point when the browser has finished parsing all of the HTML and DOM construction is complete.
      - marks when DOM is ready.
    3. domcontentloaded: marks the point when both the DOM is ready and there are no stylesheets that are blocking JavaScript execution - meaning we can now (potentially) construct the render tree.
      - typically marks when both the DOM and CSSOM are ready.
      1. domcontentloadeventstart
      2. domcontentloadedeventend
    4. domcomplete: all of the processing is complete and all of the resources on the page (images, etc.) have finished downloading - in other words, the loading spinner has stopped spinning.
      - marks when the page and all of its subresources are ready.
    5. loadevent: as a final step in every page load the browser fires an onload event which can trigger additional application logic.
      1. loadeventstart
      2. loadeventend
  - notes
    1. propagation latency: network round trips for requesting and receiving resources
### application performance
  - record a start time, do stuff, record an end time
  - node performance
    1. set the content length header:
      - aggregate the result, convert to buffer, set content-length header, and do a single res.end() call
      - if you dont do this you will get about 50% fewer requests per second
  - js performance
    1. string manipulation is costly
### browser performance
#### best practices
  - browser performance steps
    1. understand your users interaction on the page
    2. measure current app performance
    3. eliminate unnecessary downloads
    4. add compression
  - the end goal isn't to make your site perform fast on any device, it is to make users happy
    1. the majority of time users spend in your site isnt waiting for it to load, but waiting for it to respond to their actions
  - respond to users immediately; acknowledge user input in under 100ms
    1. applies to most inputs, anything clickable/toggles/animations
      - does not apply to touch drags/scrolls
    2. always provide feedback for actions that take longer than 500ms to complete
  - when animating/scrolling, produce a frame in under 10ms
  - maximize main thread idle time
  - keep users engaged; deliver content in under 1000ms or users attention will start to wander, and their perception of dealing with the task is broken
  - use idle time to complete deferred work
    1. keep preloaded data to a minimum so that your app loads fast, and use idle time to load remaining data
    2. deferred work should be grouped into blocks of about 50ms - should  user begin interacting - then the highest priority is to respond to the user
      - to allow for <100 ms response, the app must yield control back to main thread every 50ms so that it can execute its pixel pipeline, react to user input, etc.
  - eliminate/defer uneccesary downloads on app load
  - ensure each resource has compression, caching, minification, etc.
    1. inventory your content into content types and determine what content-specific optimizations can be performed
  - ensure you understand your user behavior on your page
    1. the frequency in which they interact with each element
  - GZIP performs best on text-based assets: CSS, javascript, html
  - The combination of ETag, Cache-Control, and unique URLs allows you to deliver the best of all worlds: long-lived expiration times, control over where the response can be cached, and on-demand updates.
  - optimize the critical rendering path for progressive rendering
  - if not using http2: minimize requests by combining files
  - critical path optimizations
    1. eliminate render-blocking javascript and css
    2. optimize javascript user
    3. prefer async javascript resources
    4. avoid synchronous server calls
    5. defer parsing javascript
    6. avoid long running javascript
    7. optimize css use
    8. put css in the document head
    9. avoid css imports
    10. inline render-blocking css
    11.
#### notes
  - time frames
    1. 0-16ms: users perceive animations as smooth so long as 60 new frames are rendered ever second; thats 16ms per frame (including the time it takes the browser to paint the new frame to the screen), your app has 10ms to produce a frame
    2. -100ms : respond to user action within this time frame and it will feel immediate, else the connection between action and reaction will be broken
    3. 100-300ms: users experience a slight perceptible delay
    4. 300 - 100ms: things feel part of a natural and continuous progression of tasks; loading/changing views represents a tasks
    5. 1000+ms: the user is frustrated and likely to abandon the task

##### 60 frames per second
  - 60 frames per second:
    1. 1000ms budget / 60 fps - 6ms = 10.66ms per frame
  - browsers need at most 6fps to paint each frame
  - your code should finish executing in under 10ms
  - take advantage of the first 100ms time frame to do expensive pre-calculation so that you can maximize your chances of hitting 60fps
  - always produce 60 frames per second, and every frame goes through the following steps
    1. javascript
    2. style
    3. layout
    4. paint
    5. composite
##### animations (including scrolling and touch drags)
##### HTML optimizations
  1. define as many async tags as possible
  2. minification and gzip
##### css optimizations
  1. reduce the number & complexity of css selectors
    - use specific classes as much as possible
    - avoid parent > child > blah css selectors, pseudo classes, etc.
  2. reduce the number of elements on which the style calculation must be calculated
    - typically the more important factor for many style updates
    - e.g. refrain from changing the Body/HTML tag styles
  3. keep your CSS lean, deliver it quickly as possible, and use media types and queries to unblock rendering
    - When declaring your style sheet assets, pay close attention to the media type and queries; they greatly impact critical rendering path performance.
      ```
        used on everything
          <link href="style.css" rel="stylesheet">
        only on print media type
          <link href="print.css" rel="stylesheet" media="print">
        on all media types with specific dimensions
          <link href="other.css" rel="stylesheet" media="(min-width: 40em)">
      ```
  3. measure your style recalculation costs
    - devtools > timeline > record your action> find `Recalculation` events, focus on those events that take longer than 60 FPS
  4. use BEM (or something similar): block element modifier to structure your CSS classes
  5. use transform and opacity changes for animations
    - pixel to screen pipeline: JS > style > composite
    - The caveat for the use of transforms and opacity is that the element on which you change these properties should be on its own compositor layer.
  6. investigate implementing the *FLIP Principle* for those animations violating item 5 above
  7. avoid CSS imports: The CSS import (@import) directive enables one stylesheet to import rules from another stylesheet file. However, avoid these directives because they introduce additional roundtrips into the critical path: the imported CSS resources are discovered only after the CSS stylesheet with the @import rule itself is received and parsed.
  8. inline render blocking css: For best performance, you may want to consider inlining the critical CSS directly into the HTML document. This eliminates additional roundtrips in the critical path and if done correctly can deliver a "one roundtrip" critical path length where only the HTML is a blocking resource.
  9. avoid large/complex layouts and layout thrashing
    - avoid triggering layout/reflow wherever possible
      1. avoid changes to geometric properties (e.g. width, height, top, etc)
    - assess layout model performance: flexbox > older flexbox/float-based layout models
    - avoid forced synchronous layouts and layout thrashing by reading style values before making style changes
    - reduce paitn areas through layer promotino and orchestration of animations
    - use chrome devtools paint profiler to asses paint complexity and cost; reduce where you can
  10. use devtools to identify paint bottlenecks: rendering > show paint rectangles
    - chrome will flash teh screen green whenever painting happens
    - if you see the whole screen flash green, or areas of the screen that you think shouldnt be painted, you should dig alittle further
    - you can also use the *paint profiler* to get more in-depth information
  11. promote elements that move/fade to a new layer
    - reduces the impact and complexity of repainting those elements
    - be careful, as each layer requires both memory and management
      - use DevTools to confirm that doing so has given you a performance benefit. Don't promote elements without profiling.
      - On High DPI screens elements that are fixed position are automatically promoted to their own compositor layer. This is not the case on low DPI devices because the promotion changes text rendering from subpixel to grayscale, and layer promotion needs to be done manually.
        + only promote to new layer on **low-dpi** devices
      ```
        // chrome, opera, firefox
          .moving-element {
            will-change: transform;
          }
        // safari, mobile safari
          .moving-element {
            transform: translateZ(0);
          }
      ```
  15. simplify paint complexity: changing any property apart from transforms/opacity always trigger paint
    - anything that involves blur (e.g. shadow) costs more than other painting resources
    - paint is often the longest-running of all tasks in the pipeline, and one to avoid if at all possible.
    - Ask yourself if it’s possible to use a cheaper set of styles or alternative means to get to your end result.
    - Where you can you always want to avoid paint during animations in particular,
##### javascript optimizations
  1. minimize, mangle, and remove dead code
  2. make your JavaScript async and eliminate any unnecessary JavaScript from the critical rendering path.
  3. JavaScript execution blocks on the CSSOM.
  4. JavaScript blocks DOM construction unless explicitly declared as async.
  5. executing our inline script blocks DOM construction, which also delays the initial render.
  6. When the browser encounters a script tag, DOM construction pauses until the script finishes executing.
    - in the case of an external JavaScript file the browser must pause to wait for the script to be fetched from disk, cache, or a remote server, which can add tens to thousands of milliseconds of delay to the critical rendering path.
  7. avoid setTimeout/setInterval for visual updates, always use `requestAnimationFrame` instead
    ```
      function updateScreen(time) {
        // Make visual updates here.
      }
      requestAnimationFrame(updateScreen);
    ```
  8. move long-running Javascript  off the main thread to web workers
    - you can move pure computation work to web works if it doesn't require DOM access
    - any data manipulation/traversal (E.g. sorting/searching)
    ```
      var dataSortWorker = new Worker("sort-worker.js");
      dataSortWorker.postMesssage(dataToSort);
      // The main thread is now free to continue working on other things...
      dataSortWorker.addEventListener('message', function(evt) {
         var sortedData = evt.data;
         // Update data on screen...
      });
    ```
  9. use micro-tasks to make DOM changes over several frames
    ```
      var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
      requestAnimationFrame(processTaskList);
      function processTaskList(taskStartTime) {
        var taskFinishTime;
        do {
          // Assume the next task is pushed onto a stack.
          var nextTask = taskList.pop();
          // Process nextTask.
          processTask(nextTask);
          // Go again if there’s enough time to do the next task.
          taskFinishTime = window.performance.now();
        } while (taskFinishTime - taskStartTime < 3);
        if (taskList.length > 0)
          requestAnimationFrame(processTaskList);
      }
    ```
  10. use chrome devtools timeline and javascript profile to assess the impact of javasacript
    - be very wary of micro-optimizations because they won’t typically map to the kind of application you’re building.
  11. know your javascript's frame tax: assess how much it costs to run your JS on a frame-by-frame basis, e.g. DevTools JS Profiling
    1. transitioning
    2. scrolling
  12. avoid forced synchronous layouts
    - use requestAnimationFrame to retrieve geometric values (e.g. width) at the beginning of the frame, and modify geometric values (e.g. height) after you've retrieved the values
  13. avoid layout thrashing: when you make a lot o forced synchronous layout changes in quick succession
    ``` example of layout thrashing
      function resizeAllParagraphsToMatchBlockWidth() {
        // Puts the browser into a read-write-read-write cycle.
        for (var i = 0; i < paragraphs.length; i++) {
          // read offsetWidth, the write, then read, (the second read is bad)
          paragraphs[i].style.width = box.offsetWidth + 'px';
        }
      }
    ```
    ``` fix the above example
      // Read
      var width = box.offsetWidth;
      function resizeAllParagraphsToMatchBlockWidth() {
        for (var i = 0; i < paragraphs.length; i++) {
          // Now write.
          paragraphs[i].style.width = width + 'px';
        }
      }
    ```
  13. debounce your input handlers: fixes the issue of having long running input handlers that can block scrolling, and making style changes in input handlers that cause forced syncrhonouse layouts
    - debounce visual changes to the next requestAnimationFrame callback:
    ``` example of debounced input handler
      function onScroll (evt) {
        // Store the scroll value for laterz.
        lastScrollY = window.scrollY;
        // Prevent multiple rAF callbacks.
        if (scheduledAnimationFrame)
          return;
        scheduledAnimationFrame = true;
        requestAnimationFrame(readAndUpdatePage);
      }
      window.addEventListener('scroll', onScroll);
    ```
#### image optimizations
  1. images often account for most of the downloaded bytes on a page
  2. when to use which image type
    - need animation ? *gif*
    - can you recreate this image with an SVG ? use *SVG*
    - need to preserve fine detail, with highest resolution ?
      - large (256+) color palette ? *png-24*
        - *png-8*
    - use *jpg* and experiment with quality settings
  3. image formats:
    - Vector graphics: use lines, points, and polygons to represent an image
    - raster graphics: represent an image by encoding individual values of each pixel within a rectangular grid
    - WebP: developed by google
    - JPEG-XR
  4. understand CSS vs Device pixels and the implications for high-resolution screens:
    - a single CSS pixel may contain multiple device pixels
      0. HiDPI:
      1. the more device pixels per css pixels, the finer the detail of the displayed content on screen (looks sharper)
      2. image assets require more detail (pixels) in order to take advantage of higher pixel counts
  5. optimize images by type
    - raster images:
      - reduce bit depth
        1. 8 bits per channel = 256 values per channel (16m colors)
      - lossy compression:
        1. eliminates some pixel data
      - lossless compression:
        1. compresses the pixel data
      - enable [delta encoding](https://en.wikipedia.org/wiki/Delta_encoding)
    - vector images: minify
  6. deliver scaled images
#### font optimizations
  1. pick the right font
    1. server WOFF 2.0 to browsers that support it
    2. server WOFF to majority of browsers
    3. server TTF to old android (below 4.4)
    4. server EOT to old IE(<9)
  2. compress the font
    - EOT and TTF require compression
    - WOFF and WOFF2.0 should already be compressed
    - use `zopfli` compression > gzip for fonts to get around 5% more compression
  3. use `@font-face` in css files
    - use `format()` to specify different formats that are available
    - use `unicode-range` to specify which characters you need from the font so that the entire font isnt downloaded
  4. reduce the font variants used in app to reduce font synthesis
    - if an exact font match isnt available (e.g. `font-weight: 900`), the browser substitutes the closest match
    - if no match is found (i.e. the `@font-face` declaration doesnt include an *italic* font), then the browser synthesizes its own font variant
  5. optimize loading and rendering
    - font requests are delayed until the render tree is constructed which can result in *delayed text rendering* which is part of the *critcal render path*
    - use the font loading API for lazy loading
    - use a standard font on the initial page load to unblock rendering and inject a new style that uses a web font
    - inline font data (instead of using font api) in all other cases
      1. the brwoser auto downloads with high priority CSS style sheets with matching media queries because constructing the CCSOM requires them
      2. inlining font data into CSS style sheets forces the browser to download the font with high priority without waiting for the render tree
  6. cache fonts for long periods
    - long max-age expiry
    - conditional ETag header
    - cache control policy
#### measuring performance
  1. RAIL: Response > Animation > Idle > Load
    - user-centric performance model that splits an application life cycle into four distinct steps:
      1. Response
        - input latency from tap to paint < 100ms
        - e.g. user taps a button (e.g. opening navigation)
      2. Animation
        - each frame's work (from js to paint) completes < 16ms
        - scrolling page, drags finger (e.g. to open a menu), sees an Animation
        - drags: this applies to nly the continuous phase of drags, not to start
      3. Idle
        - main thread JS work chunked no larger than 50ms
        - whenever the user isn't interacting with the page
        - the main thread should still be available enough to handle the next user input
          1. chunk work in 50ms, then check main thread before doing the next idle task
      4. load
        - page considered ready to use in 1000ms
        - user loads the page and sees the critical path content
    - use the chrome DevTools Timeline tool to record user actions and check the recorded times against these key rail metrics
      1. response: input
#### optimizing data users download
  - improving performance process starts with minimizing and optimizing the data that users download
  1. eliminate unnecessary downloads
    - inventory your & third party assets
    - measure the performance of each asset: its value and technical performance
    - determine if each resource is providing sufficient value relative to performance
      1. does the resource deliver consistent performance?
      2. is the resource in the critical path ? does it need to be?
      3. if the resource fails - does the site file ?
  2. optimize encoding and transfer size of text-based assets
    - compression: the process of encoding information using fewer bits
  3. optimize images
    - eliminate uneccesary images
    - leverage CSS3 effects: grandiest, shadows, animations, etc. can be used to produce resolution independent assets
    - use web fonts instead of encoding text in images
  4. optimize fonts
    - unicode fonts can contain thousands of glyphs
    - five font formats: no single one works on all devices
      1. WOFF2
      2. WOFF: widest support but not available on older browsers
      3. EOT: IE only
      4. TTF
      5. SVG font container: not supported by many, dont use it
    - webfont: collection of glyphs, each glyph is a vector shape that describes a letter/symbol
    - the race between the first page of page content (after the *Render tree* is built), and the request for the font resource is what creates the 'blank text problem' where the browser might render the page layout but omits any text
      1. each browser has a different method for handling this issue,
  5. use HTTP caching
    - every browser ships with an implementation of http cache
    - add relevant headers: `@see http.md`
      1. cache-control
      2. content-length
      3. etag
##### critical rendering path
  - only concerned with html markup, css and javascript
  - to optimize the CRP, minimize the following three variables
    1. critical resource: resource that could block intitial rendering of the page
    2. critical path length: number of roundtrips, or total time required to fetch all of the critical resources
      - a function of the dependency grapth between the critical resources and their bytesize: some downloads can only be initiated after a previous resources has been processed
      - the larger the resource the more roundtrips it takesto download
    3. critical bytes: total number of byte required to get to first render of the page
      - the sum of the transfer filesizes of all critical resources
  - steps to optimize the CRP
    1. analyze and characterize the critical path: the number of resources, bytes, length
    2. minimize number of critical resources: eleminate them, defer their download, mark them as async, etc
    3. optimize the number of critical bytes to reduce the download time (i.e. number of round trips)
    4. optimize the order in which the remaining critical resources are loaded:
      - download all critical assets as early as possiblet o shorten the critical path length
  - the set of steps browsers must take to convert HTML, CSS and JS into a living, breathing application
    1. optimizing the critical rendering path is the process of minimizing the total amount of time spent performing each step in browser rendering process
    2. render content to screen as quickly as possible
    3. reduce the amount of time between screen updates after the initial render
      - i.e. achieve higher refresh rates
  - browser rendering process
    1. process html markup and build DOM tree
    2. process CSS markup and build CSSOM tree
    3. combine the DOM and CSSOM into a render tree
    4. run layout on the render tree to compute geometry of each node
    5. paint the individual nodes to the screen
  - DOM Tree: captures the properties and relationships of the DOM
    1. bytes
    2. chars
    3. tokens
    4. nodes
    5. DOM
  - CSSOM: CSS object model: tells the browser how the elements in the DOM Tree will look when rendered
    1. bytes
    2. chars
    3. tokens
    4. nodes
    5. CSSOM
  - Render Tree: combines  the CSSOM and DOM trees which i used to compute the layout of each visible element and serves as an input to the paint process that renders the pixels to screen
    1. contains only the nodes required to render the page
    2. captures all the visible DOM content on the page and all the CSSOm style information for each node
    - steps.
      1. start at root of DOM Tree, travers each visible node
        - only visible tags (e.g. no `metatags`)
        - no CSS hidden elements, e.g. (no `display:none` yes `visible:none`)
      2. for each vsiible node, find the appropriate matcing CSSOM rules and apply them
      3. render vsiible nodes with conten tand their computed stules
    - Layout/reflow: is where the browser figures out the geometric information for elements: their size and location in the page.
      1. computes the exact position and size of each object
  - Paint/rasterizing: takes in the final render tree and renders pixels to screens
    1. complex styles take longer, e.g. `drop-shadow` >`color`
  - Optimizing the critical rendering path refers to
    1. prioritizing the display of content that relates to the current user action.
    2. improving the time to first render of web pages
    3. developing well-performing interactive applications
  - progressive rendering: the page is loaded with minimal content at first, and then progressively re-painted as new content is ready
    1. significantly improves the time to first render
  - unoptimized rendering: the page is not loaded until all content is ready to be displayed
  - technical explanation
    1. conversion: browser reads raw bytes of HTML and translates them to individual chars based on specified encoding ofthe file (e.g. utf-8)
    2. tokenizing: browser convers strings of chars into distinct tokens, e.g. `<html>` into an HTML dom node
    3. lexing: the emitted tokens are converted into *objects* which define their properties and rules
    4. DOM construction: the HTML markup that defines relationships between tags (e.g. some tags are parents of other tags) - the created objects are linked in a tree data structure that captures this relationship
    5. the final output of this                              is the document object model
  - non-technical explanation
    1. request HTML document
      - parse the response
      - construct DOM
      - browser discovers CSS, JS, and other resources and dispatches requests
    2. request CSS files
      - browser constructs CSSOM after all of the CSS content is received and combines it with the DOM tree to construct the *render tree*
    3. get fonts
      - font requests are dispatched after the *render tree* can tell the browser which font variants are needed to render teh specified text on the page
    4. first paint
      - if fonts are not available, the browser may not render any text pixels
    5. paint text
  - to find out how long the CSS processing takes
    1. record a timeline in DevTools
    2. look for *Recalculate style* event
  - CSS: is treated as a render blockign resource
    1. the browser wont render any processed content until the CSSOM is constructed
##### rendering performance
  - most devices refresh their screens 60x a second
    1. each of those frames has a budget of 16ms - 10ms = 10ms per frame
  - jank: when you fail to meet 10ms of your code runtime per frame, the frame rate drops and the content judders on the screen
  - pixel pipeline/pixel to screen pipeline
    1. javascript: e.g. animation, sorting, DOM modifications, css animations/transitions, etc.
    2. style: figuring out which css rules apply to which elements based on matching selectors, once rules are knonwn they are applied and the final styles for each element are calculated
      - changing the dom through adding/removing elements, changing attributes/classes, animations, will cause the browser to recalculate element styles
      - style calculations process
        1. create a set of matching selectors: browser figures out which classes, pseudo-selectors and IDs apply to any given element
        2. take all the style rules from the matching selectors and figure out what final styles the element has
    3. layout/Reflow in firefox: once the browser knows which rules to apply to an element it can begin to calculate how much space it takes up and where it is on screen
      - the web's layout model means one element can affect others, e.g. the width of the body can affect its children
      - each element will have ex/implicit sizing info based on the CSS that was used, the contents of the element or the parent element
      - triggering layout will always trigger paint
        1. any changes to **geometric properties** e.g. width, height, left, top, etc
      - Layout cost:
        1. # of elements that require layout
        2. complexity of those layouts
    4. paint: process of drawing out text, colors, images, borders, shadows, etc. that eventually get composited to the users' screen: every visual part of the element;
      - typically involves multiple *layers*
      - this is usually the longest running of all all tasks in the *pixel-to-screen* pipeline
      - changing any property apart from transforms/opacity always triggers paint
      - paint/rasterizing process
      1. create a list of draw calls
      2. filling in pixels
    5. compositing: taking the multiple layers from the paint process and drawing them to the screen in the correct order so that the page renders correctly
      - where the painted parts of the page are put together for displaying on screen.
      - two key factors in this area that affect page performance: the number of compositor layers that need to be managed, and the properties that you use for animations.
  - impact of various modification types
    1. layout property changes: i.e. modification to an element's geometry; width, height, position (e.g. left, top)
      - JS/CSS > style > layout > paint > composite
    2. paint property changes: e.g. background image, text color, shadows, etc., any property that does not affect the layout of the page
      - JS/CSS > style > paint > composite
    3. changes not requiring layout/paint:
      - JS / CSS > style > composite
  - requestAnimationFrame: any visual modifications need to occur at the start of each frame - the only way to guarantee this is to use the `requestAnimationFrame` api
  - forced synchronous layout: when you force a browser to perform *Layout* before before *Style*
    1. normal frame process: javascript > style > layout > paint > composite
    2. forced synchronous layout: javascrcript > Layout > ...
      ```
        // Schedule our function to run at the start of the frame.
          requestAnimationFrame(logBoxHeight);
        // good
          function logBoxHeight() {
            // Gets the height of the box in pixels and logs it out.
            console.log(box.offsetHeight);
            // modify style/layout properties
            box.classList.add('super-big');
          }
        // bad
          function logBoxHeight() {
            // this changes the style and modifies its Layout properties
            box.classList.add('super-big');
            // Gets the height of the box in pixels
            // and logs it out.
            console.log(box.offsetHeight);
          }
        // even worse
          function resizeAllParagraphsToMatchBlockWidth() {
            // Puts the browser into a read-write-read-write cycle.
            for (var i = 0; i < paragraphs.length; i++) {
              paragraphs[i].style.width = box.offsetWidth + 'px';
            }
          }
        // FIX for the *even worse* case
          // Read.
          var width = box.offsetWidth;
          function resizeAllParagraphsToMatchBlockWidth() {
            for (var i = 0; i < paragraphs.length; i++) {
              // Now write.
              paragraphs[i].style.width = width + 'px';
            }
          }
      ```
  - if you trigger Layout you will always trigger Paint: changing the geometry of an element means it pixels need fixing
  - you will trigger paint if you change any non-geometric properties, e.g. backgrounds, color, shadows
  - To get an understanding of the layers in your application, and why an element has a layer you must enable the Paint profiler in Chrome DevTools’ Timeline:
    1. When the recording has finished you will be able to click individual frames, which is found between the frames-per-second bars and the details:
  - avoid long running input handlers:
    + input handlers (e.g. touchstart, touchmove, touchend, etc)
      - calling preventDefault() in these input handlers will cause the compositor thread to wait until the handler has finished executing
    + input handlers (e.g. those for scroll/touch) are schedule to run just before any *requestAnimationFrame* callbacks
      - if you make visual changes in input handlers,  then at the start of the requestAnimationFrame, there will be pending style changes
      - if you then read visual properties at the start of the requestAnimationFrame callback, you will trigger a forced synchronous layout
        1. input handlers > js > style > layout > paint> composite
          - input handler = style write
          - js = style read
          - ===== forced synchronous layout
##### low bandwidth & high latency
  - emulate networking throttling to ensure adequate performance in a variety of connectivity conditions
  - skipped: check javascript_performance.md for extensive information on this section
##### PRPL
  - PRPL: pattern that takes advantage of modern web platform features to granularly deliver mobile web expieriences more quickly
    1. PUSH: critical resources for the initial uRL router
    2. RENDER: initial route
    3. PRE-CACHE: remaining routes
    4. LAZY-LOAD: and create remaning routes on demand
  - benefits of PRPL  
    1. minimum time to interactive
    2. maximum caching efficiency, espcially overtime as updates are released
    3. simplicity of development and deployment
  - requirements to use PRPL
    1. single page app
    2. the main entry pont of the app is served from every valid routes
      - all resource urls in the entrypoin tneed to be absolute, since it may be served from non-top-level urls
    3. the app-shell: which includes the top-level applogic, router, etc
    4. lazy loaded fragments of the app: a fragment can represent the code for a particular view, or other code that can be loaded lazily
    5.
##### [Chrome DevTools](https://developers.google.com/web/tools/setup/)

## AJAX: XMLHttpRequest, Fetch
## WebComponents `@see _html.md`
## Streams/WebSockets
## Tooling
## Analytics
## Front end security
### man in the middle
### cross site scripting
### [cross origin resource sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)
  - A resource makes a cross-origin HTTP request when it requests a resource from a different domain, or port than the one which the first resource itself serves.
  - the CORS mechanism gves web servers cross-domain access controls, which enable secure cross-domain transfers
    - the [CORS protocol](https://fetch.spec.whatwg.org/#http-cors-protocol) can enable cross-site HTTP requests for:
      1. invocations of XMLHttpRequest/Fetch api
      2. web fonts
      3. images/video frames drawn to canvas using drawImage
      4. stylesheets
      5. scripts
    - add HTTP headers that allow web servers to describe the set of origins that are permitted to read
    - for HTTP methods with server side-effects (e.g. `POST`), the spec mandates that browsers *preflight* the request to retrieve supported methods with an `HTTP OPTIONS` request method, and then upon *approval* from teh server, sending the actual request
    - servers can notify clients whether crednetials (e.g. cookies) should be sent with requests
  - TERMINOLOGY
    1. Simple requests: requests types that don't trigger a `CORS preflight`, i.e. GET, HEAD, POST
  - server perspective
    1. set *response.header* `Access-Control-Allow-Origin:` to the domains that can access the server's resources
      - allow all: `Access-Control-Allow-Origin: *`
      - allow specific: `Access-Control-Allow-Origin: http://foo.example`
        + you can programmatically update this permit multiple domains access without using the `*` flag
## Ecommerce
  - allow users to purchase as guests
## SEO
  - Interstitials may cause a negative impact on search rankings

## Mobile Sites
### basics
  - Make calls to action front end center
  - Make secondary tasks available through menus/below the fold
  - make common tasks easily available
  - keep menus short and sweet
  - fuck scrolling as much as possible
  - Site search bar should be above the fold, and never in a menu
  - show as much content as possible without requiring registration

## Responsive Design

## javascript engine
  - https://www.quora.com/How-does-a-JavaScript-engine-work
  - general steps
    0. source code:
    1. parser: takes js and generates an abstract syntax tree
    2. bytecode generator
    3. interpretor: converts the bytecode into machine code

## Progressive Web apps
### Offline Web Apps

### Service Workers
  - service worker: a script your browser runs in the background and listens for and reacts to arbitrary events
    + each page the service worker controls, it hijacks all events and allows you to operate on them.
    + are limited to HTTPS, since intercepting network requests can be super dangerous in the wrong hands
    1. cant access the DOM directly, but communicates with the pages it controls by responding to messages via the [postMessage](https://www.html5rocks.com/en/tutorials/workers/basics/) interface
    2. is a programmable network proxy, allowing you to control how network requests from your page are handled
    3. is terminated when not in use, and restarted when its nexted needed, so never rely on global state within a SW onfetch and onmessage handlers
    4. has full access to the indexedDB api
    5. make extensive use of promises
  - use cases
    1. adding offline support
    2. control the cache
    3. sending push notifications
      + You could send push notifications from the browser to your users about new posts, even if the client has closed your page, since service workers are in constant communication with your server in background.
    4. doing background sync with service workers
    5. Capability reporting
    6. Client-side Load Balancer
    7. Differential update of text files
    8. Support a previous unsupported image format in your browser!
    9. Save forms information even if theres no internet at the moment: Your application could have a huge form to send information for and, in case the user lost connection, the information could be saved in a Service Worker, even when the user is offline, and be sent to your server when the connection is back.
    10. Faster page loads: You could cache scripts, images, stylesheets, static pages, etc on a Service Worker on a first page-load and run a faster page loading on subsequent requests. The approach is almost the same if you relate it with browser caching but differs with when talking about requests: browser caching requests are always made and stops only if you already have the information needed and with Service Workers caching, no requests are made to the server.
    11. for some changes (e.g. minor, or security fixes) you may want to force changes to users
    12. [push notifications](https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web)
    13. [background sync](https://developers.google.com/web/updates/2015/12/background-sync)
  - life CYCLE
    1. registration step: register a SW in your page's javascript: the browser will then install the SWin the background
    2. SW Install step: you specify which static assets to cache. if all assets are successfully downloaded and cached, the SW becomes activated
      - create/open a cache
      - cache static assets
    3. SW Activated step: handle management of old caches
      - for all pages within the SW scope, the SW will act as a Proxy or be terminated (to save memory),
      - clear current cache / delete old caches if upgrading to a new version
      - have the activated service worker take control immediately
        + this is the 'idle' phase
  - process:
    1. service workers are instantiated via javascript in the window, and can only take control of pages that are LOADED after they are instantiated.
      - page 1 loads > instantiates sw registration file > makes requests (none are intercepted)
      - user refreshes (causes new load) > sw still in browser > requests are intercepted
    2. service worker intercepts all requests and triggers a 'fetch' event for each
    3. instantiating a new SW can only occur if all pages controlled by the current SW are gone. this ensures only one version of your site exists at any given time
      - the new SW is in 'waiting' mode until the current SW is gone
      - only occurs if the page closes, or the user navigates to a page not controlled by the current SW
    4. users are notified that a new SW is ready by changing the browser hamburger button in the top right (at least on chrome)
      - when the browser refetches a service worker, it goes through the browser cache for all requests
      - it is good to set your SW CACHE TIME TO ZERO!!!! this way they are updated as soon as possible
        -updates to will bypass the browser cache if the SW it has is > than the cache time
#### notes
  - use indexeddb > window.cache because indexed db has far more support
#### [window.navigator.serviceWorker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
  - service worker hijaking workflow:
    1. client loads
    2. service workers interact with caches
    3. service workers interact with http caches
    4. service workers interact with network/internet
  - network flow: browser requests > service worker > http cache > internet
  - gotchas
    - browsers only update service workers on page reload, or if there is a change to the SW (e.g. change cache name)
      + the new SW will have its only install event so you can use this time to get an updated cache
  - DEV TOOLS:
    1. click the down arrow next to 'top' and select your SW file
    2. now you can interact with your SW
      self.registration
    3. you can debug SW same as anything else:
      sources > click SW file > set breakpoints, etc.
    4. click the application/resources tab and select the SW option
  - Basic steps:
    + registration
      1. in a script on the page, register a service worker
      2. the service worker is registered on an origin, and controls a subset of paths (or root, for all paths)
        navigator.serviceWorker.register....
    + do stuff!
      1. intercept network requests/events and do something with them (e.g. store the response in cache)
        self.addEventListener....
          caches.open...
      2. events: install, fetch,
          event.someMethod()
      3. caches.open(...)
          cache.someMethod()
  - methods
    + postMessage(): send messages to/from SW
    + skipWaiting()
      - forces the waiting service worker to become the active service worker.
      - call this when a user hits the refresh button
  - events
    + INSTALL: when a browser sets up a SW for the first time, the install event is fired.
    + ACTIVATE: when a new SW is finished installing and ready to control pages, use this event to delete old caches
    + FETCH: every browser request triggers a fetch, useful for hijacking/intercepting
    + MESSAGE: receive/post messages from/to the client (i.e. a page/document)
#### window.navigator.serviceWorker by MDN tutorial
 + [url is here](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
 - step 1 is to register your someWorker.js file
  1. in your html file, include a registration.js file that registers specific service workers against an origin and path
    ```
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw-test/sw.js', {scope: '/sw-test/'})
        .then(function(reg) {
          // registration worked
          console.log('Registration succeeded. Scope is ' + reg.scope);
        }).catch(function(error) {
          // registration failed
          console.log('Registration failed with ' + error);
        });
      }
    ```
#### window.navigator.serviceWorker examples
  - registering service workers, returns a registration object
    ```
      in home.html
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('path/to/your/SW.js', {scope: 'some/path'})
          // https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration
          // https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register
          .then(function(reg) {
            // an update or initial install is in progress
            if(reg.installing) {
              // https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker
              let sw = reg.installing
                // grab this sw from the reg object
              // https://developer.mozilla.org/en-US/docs/Web/API/Client/postMessage
              sw.postMessage({...}); // send data back to service worker script
              console.log(sw.state);
                // returns installing, installed, activating, activated, redundant (thrown away)
              sw.addEventListener('statechange', function(){
                // whenever sw.state changes
                if (this.state === 'installed') //tell user to refresh browser!
              })
            } else if(reg.waiting) {
              // an update is in the pipeline and ready to be activated
              // tell the user to refresh their content! e.g. by a web socket
            }

            reg.addEventListener('updatefound', function() {
              // reg.installing is now the current worker
              reg.installing.addEventListener('statechange', function(){
                // whenever sw.state changes
                if (this.state === 'installed') //tell user to refresh browser!
              })
            })
            console.log('Registration succeeded. Scope is ' + reg.scope);
                // you can hijack requests so they are never sent to server
          }).catch(function(error) {
            // registration failed
            console.log('Registration failed with ' + error);
            });
      }
    ```
  - talk to the controlling service worker
    ```
      if (navigator.serviceWorker.controller) {
        //this page was loaded with a service worker
        const Client = navigator.serviceWorker.controller;
        Client.postMessage(message); //send message  from page to service worker
      } else {
        //this page was NOT loaded with a service worker, but grabbed from the network
        //so the user already has the latest version (duh, it came from the network)
      }
    ```
  - listen to events for all service workers from client
    ```
      navigator.serviceWorker.addEventListener('controllerchange', function() {
          //the controlling service worker has changed
        window.location.reload();
          //reload the page if the user has consented, if not ask for permission
          //for some changes (e.g. minor, or security fixes) you may want to force changes to users
      })
    ```
  - listen to events for specific service worker in SW file
    `self.addEventListener('eventName', function(event){...}) //self === service worker`
  - install event
    ```
      self.addEventListener('install', function(event) {
        event.waitUntil(somePromise);
          //retrieve files from network and create cache
          //promise resolve === accept SW continue with install
          //promise reject === reject SW and discard
      })
    ```
  - fetch event
    ```
      self.addEventListener('fetch', function(event) {
        event.respondWith(responseObjectOrPromise)
          //intercept and hijack this request
          //takes a response object or a promise resolving to a response object
          //see the fetch API 'for' the response object API
          //https://developer.mozilla.org/en-US/docs/Web/API/Response
          //return plain string
          new Response('hello world');
          //return string with custom header
          new Response('hello world', {
            headers: { headerKey: 'header value', ...}
          })
          //respond with html
          new Response("<div class='a-winner-is-me'>boom</a>", {
            headers: {
              'Content-Type': 'text/html'
            }
          });
          //hijack specific type of requests
          if(/\.jpg$/.test(event.request.url)){
            event.respondWith(
              fetch('/imgs/dr-evil.gif')
            );
          }
          //respond in event of 404 or offline
          fetch(event.request).then(function(response){
            //event.request = original object
            if (response.status === 404) return new Response('404 not found');
            //alternatively above you can return a fetch('some/other/thing')
            return response; //return original response
          }).catch(function(error){
            //no connection (offline) or some other error
            return new Response('uh oh! error/offline');
          })
      })
    ```
  - message event
    ```
      self.addEventListener('message', function(event) {
        // event.data === whatever sent from Client.postMessage
      })
    ```

## Browser Rendering Optimization

## Website Performance Optimization

## Client-Server Communications
### HTTP: hypertext transfer protocol:
  - hypertext = text with links
  - transfer protocol: rules for moving things across the web
  - clients: asks (requests) servers for resources
  - servers: store information and sends (response)
  - REST: Representational State transfer
    - state transition: going from one state (page) to another (page)
    1. separate client from server
    2. not hold state between requests (all information is sent with each response)
    3. use HTTP and HTTP methods
  - HTTP Requests:
    1. Request: tells the server what kind of request (method) is being sent
      // POST /codecademy/learn-http HTTP/1.1
    2. Header: sends the server additional information, e.g. which client is making the request
      // Host: www.codecademy.com
      // Content-Type: text/html; charset=UTF-8
    3. body: contains the data being sent
      GET: body = empty
      POST/UPDATE/DELETE: body should not be empty
        // Name=Eric&Age=26
  - [HTTP Responses](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
    - Status Codes: three digits, the starting number defines the type
    ```
      1xx: information
      2xx: success
      3xx: redirection
      4xx: client error
      5xx: server error
      6xx: unofficial Codes
        6.1: internet information services
        6.2: nginx
        6.3: cloudfare
    ```
  - [HTTP Request Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
    1. GET: retrieve data
    2. HEAD: asks for a response identical to a GET request but without the response body
    3. POST: submit data
    4. PUT: replaces data
    5. DELETE: delete data
    6. CONNECT: establishes a tunnel to the server
    7. OPTIONS: describe the communication options
    8. TRACE: performs a message loop-back test along the path to the server
    9. PATCH: used to apply partial modifications

## Accessibility:
  - Accessible: everyone can access the site's content and use it's functionality functionality
    + for users who are experiencing some time of impairment
    + the sites' content should be available to everyone
    + the sites' functionality can be operated by anyone
    + examples: events
### Accessibility users
  - visually impaired (color, near sited, far sited, braile)
    + use braile readers, text to speach, magnification (zoomed in), keyboard navigation, color contrast plugins
  - hearing impaired
  - motor
    + use hand/eye tracking software, voice dictation
  - cognitive (understanding, memory, etc) issues
  - Impairments can be:
    1. permanent
    2. temporary
    3. situational
### Accessibility technologies
  - screen readers: reads the text on the screen
  - braile keyboards: useful for blind people
### Accessibility environments:
  - desktop
  - mobile
  - screen readers
  - tablets
### Accessibility Best Practices
  + (WCAG): [Web Content Accessibility Guidelines](https://www.w3.org/TR/WCAG20/)
    - [AIM Checklist](http://webaim.org/standards/wcag/checklist)
    - POUR Guidelines
      1. Perceivable: users can perceive content
      2. Operable: users can navigate
      3. Understandable: users can understand the content and interface and avoid confusion
      4. Robust: can a wide variety of agents consume the data
  + functionality
    - keyboard navigation
    - shortcut keys
  + Style and visual design:
    - text color should be high contrast with background color for readability (sight)
    - should be minimal to help with understanding the page
    - check your design patterns against aria: https://www.w3.org/TR/wai-aria-practices/
  + Forms:
    - Inputs and labels should be close enough together for understanding the relation between the two
      + if they are two far apart, you cant zoom in and see the relation (site)
    - labels should activate inputs
  + Audio
    - audio should be accompanied with visual actions
  + [Managing focus](https://www.w3.org/TR/html5/editing.html#focus-management)
    - focus: the control on the screen that receives input from the keyboard and clipboard when you paste/type
      + determines where keyboard events go
      + not all elements are focusble by default, and will not be included in the tab order
  + Managing shortcuts:
    - implement the following:
      + some environemnts enforce all keyboard commands to also use command (e.g. on mac)
      + tab order: move through focusable (i.e. interactive elements, e.g. input, select, button) and not content elements (e.g. div )
        - elements are inserted into the tab order based on their position in the DOM
        - using css tabIndex to control the tab order
          + try to always use the natural tab order
        - an exception to adding tab order to non-interactive elements is when you're managing focus:
          1. reloading parts of a page without a full page refresh, and need to indicate to user what has changed
          2. in page navigation,  e.g. through #anchor links and need to inform user
      1. tab: move forward
      2. shift tab: move backward
      3. arrow keys: move within a component
      4. spacebar: select/deselect
    - skip links: allows keyboard users to skip to main content
      + `<a href='#your-main-content-id' class='skip-link'> skip to main content </a>`
        - this element should be position off screen when not focused (e.g. left: -40px;), and positioned on screen (E.g. top left corner) when focused
      + your main content should have a parent elementwith the corrosponding id
        - make sure to add tabindex='-1'
      + http://webaim.org/techniques/skipnav/
    - roving focus: perfect for radio buttons, so that keyboarding through items in the radio will loop through from beginning to end
      + set the currently checked item to tabindex=0, and all other buttons inthe group to tabindex='-1' via an event listener
    - manage offscreen / hidden content that receives focus but does not appear on screen
      + you can log window.activeElement to get the exact element that is currently focused
      + check the chrome dev tools accessibilty audit chrome plugins
      + best practices:
        1. set visibility: hidden, display: none for offscreen/hidden items so they cannot receive focus, then do the opposite when they are to be visible/on screen
    - manage keyboard/modal traps
      - when you click into a (e.g a select element) in a modal, you may be unable to tab out of it, as the tab shortcut is trying to finish your autocomplete info
      - or when you are on a modal, and the modal is open but the user tabs out of the modal and returns to the main page but the modal is still open so the page looks disabled
        + keep track of the element that had focus before the modal was opened
        + trap the focus inside the modal until closes
          - this is done by listening for tab & shit.tab events and programmatically calling focus() to elements you allow
        + return focus to the previous element
  + Touch points:
    1. DOM order
    2. Managing focus
    3. Managing navigation via tabindex
    4. Keyboard shortcuts
    5. Semantics
    6. Labeling inputs
    7. Headings in sections
    8. Landmarks (html structural elements)
    9. Links
    10. ARIA roles and design patterns
      - https://www.w3.org/TR/wai-aria-1.1/#role_definitions
      - https://www.w3.org/TR/wai-aria-practices-1.1/
      - https://www.w3.org/TR/html-aria/
    11. Ensuring only appropriate sections of a document are exposed to assistive technologies, or hidden from non-assistive technologies
      - http://webaim.org/techniques/css/invisiblecontent/
    12. ensuring LIVE regions (i.e. updates) are communicated to users
    13. managing the styles and using aria-attributes instead of classes
    14. ensuring you have a responsive design for multiple devices
    15. breakdown existing acciessibility issues based on:
      1. is this a critical piece of the app functinoality?
      2. how frequently is this piece of UI/UX used?
      3. do we need to fix this?
    16. all of the above should ensure the ACCESSIBILITY TREE is as it should be
### Accessbility Semantics
#### Assistive technologies
  - assistive technologies: umbrella term that helps users complete some task
    +  browser zoom, braile display, voice control, screen readers, etc
#### Programmatically Expressed Semantics
  -  Semantics: the elements, and its attributes, is used in a way facitilitates its meanings programmaticaly to describe its functionality
    + for all user interface components:
      - the name and role can be programmatically determined
      - states, properties, and values can be programmatically set
    + screen readers convert a visual page into auditory sounds that users can enter information into
  - Attributes:
    + Role: what type of element it is
      - e.g. 'Edit Text'
    + Name (i.e. label text or text alternative): if it has one
      - Text Alternatives: for elements that do not have labels, e.g. images, buttons, etc.
        + the text associated with these (e.g. in the alt= or as a text node) because its name/label
        + imagine all your images are broken, and think of what you would need in the alt= to understand what the image should be
    + Value: if it has one
    + State: if it has any
  - The Accessibility tree: screen readers take the DOM and strip away its visible elements, to create an accessibility tree based on the programmatic semantics of the html elements
    + its all based on role, name, value, and state
  - Navigating Content: links, form controls, headings, and landmarks
    + Link Text: should be descriptive, not just 'click here', but the text should tell you exactly where it go
      - all links should have an href
      - the href= should never be href=#
      - anchors with child images: the image must have an alt text
    + Landmarks: describe areas of a page, versus a single element
      - main: only one per page
      - header: page banner or grouping element for introductory content for a section
      - footer: a page footer or grouping element for a section of a page
      - nav: a section of a page that links to other pages, or parts within a page
      - article: self contained sections of content, e.g. blog entry, forum posts, etc.
        + will the ocntent make sense in a another context?
      - section: generic section of a document or application
        + should contain a heading
      - aside: tangentialy related to the content around it
    + Headings: are the best thing to implement for screen readers
      - HEading order: follows the DOM Order and not the visual order of the page
        + get dom order of headings:
          ```
            for (var i = 0, headings = $$('h1,h2,h3,h4,h5,h6');
                 i < headings.length; i++) {
               console.log(headings[i].textContent.trim() + " " +  
                           headings[i].tagName,
                           headings[i]);
            }
          ```
        + you can include headings off screen to help with screen readers, but do not go overboard
          - i.e. headings absolutely positioned off screen
#### Semantics ARIA
 + ARIA is used to express semantics that native html elements cannot express on its own
  - https://www.w3.org/TR/wai-aria-1.1/
  - modifies how elements are translated into the accessibility tree via custom attributes
    + great when you need to use a div (instead of a checkbox) but still need that div to show up as a checkbox to assistive technologies
  - ARIAs only purpose is to modify the accessibility tree, it does not:
    + modify element appearance
    + modify element behavior
    + add focusability
    + add keyboard handling
      - all of the above must be handled by javascript ;)
  - ARIA breakdown:
    + role: the semantic meaning of the element
      - includes superclass, subclass, and related concepts (roles) that have similar, but not identical semantics
    + inherited states/properties: attributes that can be used with the given role, some are requied, others are optional
    + Name from: where the name (label) will be retrieved from, e.g.
      - the text content
      - or the html author
    + important attributes:
      - name:
        - aria-label: screen reader only name
        - aria-labelledby=id: specify another element that provides the name for this element
        - aria-describedby=id: additional text describing this element is provided by some other element
      - ARIA landmark roles: banner, navigation, main, complementary, search, dialog, contentinfo
      - relationships:
        + aria-owns="id1 id2 id3 idX" specify this element owns the other element(S), and should be listed as the parent of them all in the accessibility tree
          + this modifies the hierarchy of the accessibility tree
        + aria-activedescendant='idX': when the parent has focus, this element should actually be the one given focus
          - this way the parent can keep actual focus and receive keyboard events, while the idX is updated to the element that should be visually given focus
        + aria-describedby: extra explanatary text that a user may need
        + aria-posinset: 1-based position in set, e.g. x out of y. used with aria-setsize
        + aria-setsize: relationship between sibling elements in a set, used with aria-posinset
          -  perfect for lazy loading, to specify the total number of items in a set, even when some of the items have not been loaded yet
        + aria-hidden: hide elements from assistive technologies
        + aria-live=off|polite|assertive: specify that updates should be communicated to users as soon as it hits the DOM
          - e.g. status updates
          - polite: alert when no other alerts are happening
          - assertive: interrupt and alert immediately
          - aria-live region should be in the initial page load
          - set it on the parent most element
          - related attributes:
            + aria-atomic: whether the entire region should be communicated to the user
            + aria-relevant=additions|removals|text|all: what should be communicated to the user
      - states
        + aria-pressed: indicated if the state of this button/interactive element is pressed|clicked
        + aria-hidden: element is hidden
        + aria-expanded: element is open
### Accessibility Styles
  + importing styles:
    - style via aria attributes with attribute selectors: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors
  + Focus
    - Styles: :focus, :hover, :before,
    - properties: outline, box-shadow
      radio:focus::before { some styles }
  + Design
    - always use <meta name=viewport
    - always use responsive grid
  + Fonts:
    - use relative units as much as possible (e.g. em, rem)
  + Touches:
    - at least 48dp minimum touch size per touch target (average size of a finger)
    - at least 32dp minimum margin around touch targets (so you dont accidently touch another thing)
  + color and contrast:
    - contrast ratio: body text and images have a high contrast with background color
      + http://webaim.org/resources/contrastchecker/
    - dont convey info with color and contrast alone, always provide additional help text

## Forms:
  - best practices
    1. should have progress meter
    2. should be quick to finish
    3. validation messages should be clear and located next to their errors
    4. inputs should have placeholders
    5. inputs should autocomplete based on users known data
    6. always realtime validation
	- links
    - [creating amazing forms](https://developers.google.com/web/fundamentals/design-and-ui/input/?hl=en)
    - [Location Example](http://www.html5rocks.com/en/tutorials/geolocation/trip_meter/)
    - [mdn forms guide](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms)
    - [mdn sending form data](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Sending_and_retrieving_form_data)
  - background
    + HTML Forms are one of the main points of interaction between a user and a web site or application.
### validation
    - [constraint validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation)
    - types of form constraints:
      1. intrinsic: basic validation provided by setting the `type=blah` attribute, e.g. email
      2. basic: setting validation related attributes
        + `pattern|min|max|required|step|maxlength`
    - triggering constraint validation process: happens either at the form level, or the input level
      1. invoke checkValidity() method on an input/select element
      2. invoke checkValidity() method on the form element ( statically validating the constraints.)
      3. submitting the form ( interactively validating the constraints.)
      4. trigger JavaScript on some form field event (like onchange) to calculate whether the constraint is violated
        - use the method `field.setCustomValidity()` to set the result of the validation:
          + empty string: constraint is satisfied
          + non empty string: there is an error and this string is the error message to display to the user.
#### [validity states](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState)

  - The ValidityState interface represents the validity states that an element can be in, with respect to constraint validation. Together, they help explain why an element's value fails to validate, if it's not valid.
  - used like this: `someInput.validity.someProperty`
  + validity properties:
### validation styling via css pseudo classes
  - `:required`
  - `:valid`
  - `:invalid`
### Form Examples
  - label with datalist
    ```
      <label>
          Choose Event Type:
          <input list="eventTypes" name="myBrowser" />
      </label>
      <datalist id='eventTypes'>
        <option value='Party'>
        <option value='Meeting'>
        <option value='Conference Talk'>
        <option value='Sports Game'>
      </datalist>
    ```

## promises and asynchronous code
  - asynchronous: statements occur in multiple timelines, in an unknown order irregardless of how they are defined in code
      e.g. network requests, events, threads, timeouts, etc.
  - synchronous: statements happen in order as defined, in a single timeline
  - callbacks: pass one function (cb) to another function, and the cb is invoked when certain conditions are met
    + problems:
      1. how do you handle errors ? do all type of errors get handled the same way ?
      2. Pyramid of doom / callback hell:
### Promises:
  - try catch wrapper around code that will finish at an unpredictable time
    1. can only succeed/fail once
    2. cannot switch from success to failure/vice versa
    3. if a promise has succeeded/failed, and you later add a success/failure callback, the correct callback will be invoked, even though the event took place earlier
    4. any object with a then method can be used as and integrated with native promises
  - Promise States
    1. fulfilled (resolved): action related to the promise has succeeded
    2. rejected (failure): action related to the promise has failed
    3. pending: not yet fulfilled / rejected
    4. settled: promise has either fulfilled / rejected.
      - a promise can only be settled once, whereas events can fire multiple times
      - promises are potentially blocking since they are created and settled on the main thread
  - Promise stages:
    1. wrapping: (value promise creation)
      + create a promise that wrapps an async action
    2. thening (value -> action):
      + any object that returns a .then is thenable
      + any thenable can become part of a chain of thens/asynchronous work
    3. catching (value -> recovery):
      + javascript calls the NEXT CATCH in the chain when an error occurs or a promise is rejected
      ```
        all of the below are the same
        .catch(....)
        .then(undefined, rejectFunc)
        .then(resolve, rejectFunc)
      ```
    4. chaining (value -> promise):
  - Promise Methods
    1. `Promise.Resolve()`: create a promise thats resolves to whatever value you give it
      ```
        var blah = Promise.Resolve();
        blah.then(...);
      ```
    2. `Promise.Reject()`: see Promise.Resolve();
    3. `Promise.all([pro1, pro2,...])`: takes an array of promises and returns an array of values in the same order as the original promises
        ```
          Promise.all([...])
            .then(...)
        ```
        - fails fast: will reject as soon as the first promise rejects, without waiting for the remaining promises to settle
    4. `Promise.race(array)`: make a promise that is settled as soon as any promises in the passed array are resolved/rejected
  - notes
    1. each Then is also asynchronous, so you can return a promise from a then, and the next then will only execute when the new promise is settled
    2. the `.catch()` chain is just sugar for `then(successFunction, errorFunction)`
    3. promise rejections skip forward to the next then() with a rejection callback or catch chain
    4. rejections happen when a promise is explicitly rejected, or implicetly if an error is thrown in the constructor callback
      - thus, its best to do all your promise-related work inside the promise constructor callback, so errors are automatically caught and become rejections
    5. you can combine generators and promises to write async code that looks like and easy to follow like sync code
#### Promise constructor:
  ```
    // create promise and assign to const
    const Promised = new Promise((resolve, reject) => {
      // resolve and reject are callbacks
      if (true) resolve(successData);
      else reject(ErrorObject);
      // do some other stuff
      // even if resolve is called first, finish all code inside of this block
    });

    // take action when promise is settled
    Promised.then(
      (successData) => {
        // sucessData = whatever is passed to resolve()
      }, (errorData) => {
        // errorData = whatever is passed to reject()
      }
    ).catch(rejectFunction) // handles both reject and javascript errors
    .then(someNamedFucntion) // passed a name function that accepts the argument
    .catch(...) // thens and catches *can* come right after each other
    .then(....)
    .then(undefined, rejectFunc) // this is long form of .catch(...)
    .then(resolve, reject) // combine both .then and .catch in one go
  ```
#### Promise Chaining
  **Cast a thenable object to a standard promise**
  ```
    const cast = Promise.resolve({ then: () => {
      // this is my thenable object cast to a promise;
      }})
    cast.then(...)
  ```
  **Series: multiple promises run sequentially**
  ```
    var sequence = Promise.resolve(); // create a promise without the new keyword, can also use Promise.reject()
    blah.forEach(function(url) {
      sequence = sequence.then(...); //each request is added to the previous request and executed in sequence
    })
  ```
  **Parallel: multiple promises run concurrently**
  ```
    var sequence = Promise.resolve(); // create a promise without the new keyword, can also use Promise.reject()
    blah.forEach(function(url) {
      sequence.then(...); //each request is fired independently and in parallel
    })
  ```
  **Each then can transform the value returned from the previous**
  ```
    somePromise
      .then((value) => value++)
      .then((value) => value++)
  ```
### Async
  - links
    1. [jake archibald async explanation](https://developers.google.com/web/fundamentals/getting-started/primers/async-functions)
    - [another jake archibald](https://jakearchibald.com/2014/es7-async-functions/)
  - basics
    1. allow you to write promise-based code as if it were syncrhonous, but without blocking the main thread
    2. Note that `await` may only be used in functions prepended with the `async` keyword
    3. suspends execution in your context until the promise settles
    4. `async` Function always returns a Promise
    5. anything prepended with `await` is passed through Promise.resolve() so you can safely await non-native promises
  - use cases
    1. reduce complex promise logic
    2. convert object/class methods to promises
      - Class constructors and getters/settings cannot be async.
    3. easily run multiple async logic in serial/parallel
    4. easily make requests in parallel but take action in order they were called
    5. use them on every promise-returning function! Not only do they make your code tider, but it makes sure that function will always return a promise.
#### examples
  **async arrow function**
    ```
      async ()=> {
        var data = await makeCall();
      }
    ```
  **async function with try catch**
    ```
      async function myFirstAsyncFunction() {
        try {
          // execution is suspended in a non-blocking way inside of this block until the promise is resolved or rejected,
          const fulfilledValue = await promise;
        }
        catch (rejectedValue) {
          // …
        }
      }
    ```
  **async function used with array map**
    ```
      const jsonPromises = urls.map(async url => {
        const response = await fetch(url);
        return response.json();
      });
    ```
  **async function as a object method**
    ```
      const storage = {
        async getAvatar(name) {
          const cache = await caches.open('avatars');
          return cache.match(`/avatars/${name}.jpg`);
        }
      };

      storage.getAvatar('jaffathecake').then(…);
    ```
  **async function as a class method**
    ```
      class Storage {
        constructor() {
          this.cachePromise = caches.open('avatars');
        }
        async getAvatar(name) {
          const cache = await this.cachePromise;
          return cache.match(`/avatars/${name}.jpg`);
        }
      }

      const storage = new Storage();
      storage.getAvatar('jaffathecake').then(…);
    ```
  **A function with multiple await expressions will run each in serial.**
    ```
      async ()=> {
        var data = await makeCall();
        var data2 = await makeCall2();
        var data3 = awat makeCall3();
      }
    ```
  **async function ran in parallel**
    ```
      async function parallel() {
        const wait1 = wait(500);
        const wait2 = wait(500);
        await wait1;
        await wait2;
        return "done!";
      }
    ```
  **request in parallel, process in order**
  ```
    async function logInOrder(urls) {
      // fetch all the URLs in parallel
      const textPromises = urls.map(async url => {
        const response = await fetch(url);
        return response.text();
      });

      // log them in sequence
      for (const textPromise of textPromises) {
        console.log(await textPromise);
      }
    }
  ```
  **to run a bunch of calls at the same time**
    ```
      async function concurrent () {
        var [r1, r2, r3] = await Promise.all([p1, p2, p3]);
      }
    ```
  **another version of the above**
    ```
      const all = Promise.all.bind(Promise);
      async function concurrent () {
        var [r1, r2, r3] = await all([p1, p2, p3]);
      }
    ```
## Javascript language
  - is single threaded: two things cannot run at the same time
    1. Javascript is in the same queue as painting, updating styles, and handling user actions (e.g. highliting text/interacting with form controls)


## [EVENTS](https://developer.mozilla.org/en-US/docs/Web/Events)
  - Event Registration: telling javascript you want to react to specific events when they happen via an event handler
    1. using tag attributes
      `onclick="alert('show this message on click')"`
    2. using dot notation
      `document.getElementById('blah').onclick=function(){alert('show this message on click');}`
    3. using addEventListener()
      - it allows us to check for multiple events in a single call (aka event propagation)
      - and events can be triggered via non DOM objects (i.e. write your own events)
      - it is not supported by IE 8 or lower (you have to use an if statement to check for the other one)
 - event.preventDefault(): stops the browser from continuing to process the event, it does not stop propagation
 - event.stopPropoagation(): prevents further propagation of the event in the capturing and bubbling phases
 - Event objects
    - capturing an event returns an event object
    - event objects will be different in each browser, console log it to see:
    - event info
        1. type = e.g. click
        2. timestamp = the time it happened
        3. defaultPrevented = if you are preventing the default behavior
    - event targeting info
        1. currentTarget = the element the event was assigned to
        2. target = the element the event originated from
        3. srcElement = the actuall element that fired the event
        4. fromElement = mouse over and mouse out events
        5. toElement = mouse over and mouse event events
    -  coordinate info:
        1. screen X,Y: position relative to the users screen
        2. layer x, y: position relative to the another positioned event
        3. client x,y: position relative to the window
        4. page x,y: position relative to the document
        5. offset x,y: position relative to the element that fired the event
    - key/mouse info
        1. charCode/Keycode: which character was pressed
        2. altKey:
        3. shiftKey:
        4. ctrlKey:
        5. button:
    - Event propagation
      - a parent event can capture events from is child elements
      - only available when using addEventListener
    - capturing phase: moves down from parent to child element
    - bubbling phase: moves up from child to parent element
    - stopping propoagation
      `e.stopPropoagation()``
      - stop the event from moving up/down the DOM
      - use this after you're done with the event
    -  Event Default behavior
      - clicking on links, submitting forms, etc.
      `e.preventDefault() //stops the default behavior`
### [ADD EVENT LISTENERS](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
  ``` add events
    target.addEventListener(type, listener[, options]);
    target.addEventListener(type, listener[, useCapture]);
    target.addEventListener(type, listener[, useCapture, wantsUntrusted  ]); // Gecko/Mozilla only
        - target = domnode|document|window
        - type = event
        - listener = js function|callback, gets passed the event object as its only argument
        - type: string; event type
        event types:
        - listener: an object that receives a notition that implements the event interface or is some other capable javascript function
        - options: object that specifies characteristis about the event listener containing properties capture, once, passive, and mozSystemGroup
  ```
### [REMOVE EVENT LISTENERS](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener)
### [TOUCH EVENTS](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events)
	- background
		+ low level APIs to support application specific touch interactions like two finger gestures
		+ are similar to mouse events except they support simultaneous touches and at different locations on the touch surface
		+the TouchEvent interface encapsulates all of the touch points that are currently active
	- events: touchstart, touchmove, touchend, touchcancel, tou
  - tips
	 + setup event handlers on the body.onload attribute and attach event handlers to all elements that require it
	 + calling evt.preventDefault() on touchstart / first touchmove will cancel mouse events
		 - instead only call preventDefault() on touchmove, or fire touch events as mouse events
  - Use the event object to tailor actions to events.
    + Each touch event includes three lists of touches.
      1. touches: a list of all fingers currently on the screen.
      2. targetTouches: a list of fingers on the current DOM element.
      3. changedTouches: a list of fingers involved in the current event. For example, in a touchend event, this will be the finger that was removed.
    + These lists consist of objects that contain touch information:
      1. identifier: a number that uniquely identifies the current finger in the touch session.
      2. target: the DOM element that was the target of the action.
      3. client/page/screen coordinates: where on the screen the action happened.
      4. radius coordinates and rotationAngle: describe the ellipse that approximates finger shape.
  - some mobile browsers will select text if a user long touches on the screen, which can be super annoying, disable by:
    - moz-user-select: none;
    - webkit-user-select: none;
    - ms-user-select: none;
    - user-select: none;

## design patterns
### creation patterns
#### factory pattern:
	- a function that creates other objects based on supplied arguments
	- e.g. document.createElement() creates html elements of the given type
	- you should always run validation on the arguments before creating the requested object
#### singleton pattern:
	- a 'class'/object/module/etc that only has one instance with a global point of access (so it can be accessed anywhere)
	- the singleton is not the class/object/module, but it is the logic that ensures there is only one instance of the class/object/etc
		- you either return the instance, or you create and then return the instance
			return instance || (instance = createInstance());
#### [constructor pattern](http://www.samselikoff.com/blog/some-Javascript-constructor-patterns/)
  - Prototypes let you share public methods across objects. (They also let you use inheritance).
  - Closures let you have private properties and methods. They are often used in libraries. (Closures are part of a larger pattern called the Module pattern).
  - Custom constructors can be useful when building specialized APIs.
  - Object literals are often used to store and pass around isolated chunks of data, like configuration settings or the parameters to an AJAX request. They can also help reduce the number of globals in your code.
	- using instance = new Constructor(blah, bloop);
    1. `this` points to the instance inside of the constructor
  - if you want a function to be shared across all instances, set it as a method on the constructor's prototype
    `Constructor.prototype.someMethod = function() { poop }`
### structural patterns
#### callback pattern
  ```
		function randomCallBack(goodData, callback){
		  //both get called
		  callback(undefined, goodData); //no error, good data returned
		  callback('error message', undefined); //error, setting good data undefined
		}
  ```
  ```
		randomCallBack('something to send to callback', function(err, gooddata){
		  if (err) {
		    console.log(err);
		  }else {
		    console.log('good data');
		  }
		})
  ```
#### promise pattern
  ```
		function randomPromise(otherdata){
		  return new Promise(function (resolve, reject){ //make sure to return THIS!
		    setTimeout(function(){
		      console.log('past resolve & reject function calls in here to fake delay');

		    }, 5000)
		    //if things go good, call resolve
		    return resolve('good data'); //make sure to return

		    //all things bad, call reject
		    return reject('error message here'); //make sure to return
		  });
		}
  ```
  ```
			randomPromise('ooh send this to promise')
		  .then( //only success or err is called
		    function(success){
		      console.log('promise success received: ' + success);
		    },
		    function(err){
		      console.log('promise error received: ' + err);
		    }
		  );
  ```
#### facade pattern:
	- any function that wraps other functions to make them easier to use
	- function A: has 10 methods related to calling, 20 methods related to talking, and 2 methods related to pooping
	- function B has three methods: call, talk, hangup, that  utilize  all of function A methods but only allows the user to use the three functions available.
		- this allows you to call talk and hangup, without having to know about the 1000 methods of function A.
#### command pattern:
	- separate the responsibility of issueing commands from executing commands
	- objects are usually nouns (person, place, or thing) but are used as verbs (walk, run, talk)
	- object A = noun: has properties needed to take actions and methods to issue (request) actions, but does not execute any actions
	- object B = verb, has all of methods needed to execute commands that other objects issue (request)
    ```
			// create a calculator object (noun)
			function Calculator() {
				this._currentValue = 0;
				this.commands = []; //list of commands used, in order
			}

				Calculator.prototype = {
					//issue the command
					execute: function (command) {
						this._currentValue = command.execute(this._currentValue);
						this.commands.push(command); //add this command to our commands array
					}
					getCurrentValue: function() {
						return this._currentValue;
					}
					undo: function () {
						var cmd = this.commands.pop(); //get the last used command
						this._currentValue = cmd.undo(this._currentValue);
					}
					comm
				}

				//create a command object (verb) that executes commands
				function Command(fn, undo, value) {
					this.execute = fn; //execute this function, e.g. Add
					this.value = value; //keep track of value
					this.undo = undo; //keep track of the undo fn, e.g. Sub
				}

				//commands to execute
				function add(value) {
					return value + this.value;
				}
				function sub(value) {
					return value - this.value
				}
				function AddCommand(value) {
					Command.call(
						this, //this arg inside command
						add, //execute
						sub, //undo
						value //the value supplied by user
					)
				}
				function Subcommand(value) {
					Command.call(
						this, //this arg inside command
						sub, //execute
						add, //undo
						value //the value supplied by user
					)
				}

				var thisCalc = new Calculator();
				calc.execute(new AddCommand(5)); //adds 5 to 0 the initial number
				calc.execute(new AddCommand(5)); //adds 5 to 5
				calc.execute(new Subcommand(10)); //removes 10 from 10
    ```
### code reuse patterns
#### abstract 'class' pattern:
	- `'class' A` is a base 'class' whose only purpose is to create subclasses
	- you will never issue var blah = new BaseClass{};
	- you will always issue class Blah extends BaseClass {};
#### subclassing pattern
	- inheriting properties for a new object to a base / superclass object
	- class A = super class / base object
	- class B = subclass
	- class B extends class A () {...}
		1. all instances of B inherit methods from A
		2. B can override methods of A
		3. B can invoke methods of A that has been overridden (method chaining)
			- B overrides method 1, B can still call method 1 from A via method chaining
		4. B can invoke the constructor of A via constructor chaining

		basic workflow:
			1. inside subclass, call parent constructor via Parent.call(this,arg1, arg2,etc);
			2. immediately after subclass definition, set prototype inheritance, Subclass.prototype = Object.create(Parent.prototype)
		- extended example: ES5
      ```
  				//define the base class
  			var	Person = function( firstName , lastName ){
  					this.firstName = firstName;
  					this.lastName =  lastName;
  					this.gender = 'male'
  			}

  			//a new instance of Person can then easily be created as follows:
  			var clark = new Person( "Clark" , "Kent" );

  			//Define a subclass constructor for for 'Superhero':
  			var Superhero = function( firstName, lastName , powers ){
  					/*
  							Invoke the superclass constructor on the new object
  							then use .call() to invoke the constructor as a method of
  							the object to be initialized.
  					*/
  					Person.call(this, firstName, lastName);
  					//Finally, store their powers, a new array of traits not found in a normal 'Person'
  					this.powers = powers;
  			}
  			//assign the Person prototype to the Superhero prototype to ensure all methods are passed over
  			Superhero.prototype = Object.create(Person.prototype);
  				//new X is Object.create(X.prototype) with additionally running the constructor function. (And giving the constructor the chance to return the actual object that should be the result of the expression instead of this.)
  			var superman = new Superhero( "Clark" ,"Kent" , ['flight','heat-vision'] );
  			console.log(superman); /* includes superhero props as well as gender*/

    		-extended example: ES6
    			class Person {
    				constructor(props) {
    					this.firstname = props.firstname,
    					this.lastname = props.lastname,
    					this.gender = props.gender || 'male'
    				}
    			}
    			let noah = new Person('noah','hall');
        ```
#### inheritance pattern:
#### mixin pattern:
	- share methods across multiple objects/classes
	- take object A and mixin the methods/properties of object B
	- a mixin is a 'class' that contains methods for use by other classes without having to be the parent 'class' of those other classes.

    ``` in jquery
  		$.extend(TargetObject, source1, source2, ...);
  			TargetObject gets functionality from source
    ```
  	```example 2
  		https://www.youtube.com/watch?v=fTNb4yo3S3c&list=PLrzrNeNx3kNHsaPfrpPo0AlW-MhJE6gOA&index=14
  		function extend(target) {
  			if (!arguments[1]) return; //multiple source objects can be sent in

  			// copy source methods and props over to target
  			for var (i = 1; i < arguments; i++){
  				var source = arguments[i];
  				for (var prop in source) {

  					//only copy properties that the target does not have and that the source owns (no prototypical properties)
  					if (!target[prop] && source.hasOwnProperty(prop)) {
  						target[prop] = source[prop]
  					}
  				}
  			}
  		}
    ```
  	```example 1 from wikipedia
			//https://en.wikipedia.org/wiki/Mixin
			var EnumerableFirstLast = (function () { // function based module pattern.
			    var first = function () {
			        return this[0];
			    },
			    last = function () {
			        return this[this.length - 1];
			    };
			    return function () {      // function based Flight-Mixin mechanics ...
			        this.first  = first;  // ... referring to ...
			        this.last   = last;   // ... shared code.
			    };
			}());

			// Application - explicit delegation:
			// applying [first] and [last] enumerable behavior onto [Array]'s [prototype].
			EnumerableFirstLast.call(Array.prototype);

			// Now you can do:
			a = [1, 2, 3];
			a.first(); // 1
			a.last();  // 3
    ```
#### decorator pattern
	- wrapper used to extend functionality of an object without rewriting it
	- useful for modifying existing systems where you may wish to add additional features to objects without the need to change the underlying code that uses them.
	- function A takes function B as an argument, before calling function B it has logic to see if it 'should' call function b
		- how functions are defined without decoration
      ```
				class Blah {
					someMethod() {
						return 'stuff';
					}
				}
				//is really this
				Object.defineProperty(Blah.prototype, 'meo', {
					value: specifiedFunction,
					enumerable: false,
					configurable: true,
					writable: true
				});
      ```
		- property decoration es6
      ```
  			function readonly(target,key,descriptor) {
  				descriptor.writable = false;
  				return descriptor;
  			}
  			//use it like this
  			class Blah {
  				@readOnly
  				someMethod() {
  					return 'stuff';
  				}
  			}
      ```
	 	- property decoration es5
      ```
  			function AuthorizationDecorator(protectedFunction) {
  			    return function() {
  			        if (user.isTrusted()) {
  			            protectedFunction();
  			        } else {
  			            console.log('Hey! No cheating!');
  			        }
  			    }
  			}
  			//Using it would look like this:
  			AuthorizationDecorator(save);
      ```
#### behavior patterns
	- observer patterns:
		- defines an object (subject) that notifies other objects (observers) when its state changes
		- javascript and the DOM are implemented with the observer pattern
		  ```example
				document.addEventListener('click', function(evt){...});
				document = subject
				function = observer
				when the click happens, the document publishes the event to all its subscribers
      ```
	- publish subscribe pattern:
    ```
			function pubSub() {
				var subscribers = {};

				//
				function subscribe(type, fn) {
					//type: event your subscribing to
					//fn: observer

					//if type array does not exist, add it
					if (!subscribers[type]) {
						subscribers[type] = [];
					}

					//if observer is not associated with type, then add it
					if(subscribers[type].indexOf(fn) == -1) {
						subscribers[type].push(fn)
					}
				}

				function unsubscribe(type, fn) {
					//get array of all observers of this type
					var listeners = subscribers[type];
					if(!listeners) return;

					//remove observers
					var index = listeners.indexOf(fn){
						if (index > -1) listeners.splice(index,1)
					}
				}
				function publish(type, evtObj) {
					if (!subscribers[type]) return;
					if(!evtObj.type) {
						evtObj.type = type;
					}

					//publish the event data to all observers
					var listeners = subscribers[type];
					for (var i=0;i.listeners.length;i++){
						listeners[i](evtObj)p
					}
				}

				return {
					subscribe: this.subscribe,
					unsubscribe: this.unsubscribe,
					publish: this.publish
				}
			}
    ```
	  - use pubsub:
      ```
				function observer1(evt){
					console.log('got observed evt', evt)
				}
				pubSub.subscribe('someEvent', observer1);
				pubSub.publish('someEvent',, {this:'is the evtObj'});
				pubSub.unsubscribe('someEvent', observer1)
      ```
#### module patterns
	- Basic pattern
		- you namespace your code in an immediately invoked function, so that it provides privacy to your real functionality
		- whatever you return is publicly accessible
		- utilize functional scope and closures
  - Modules: allow you to reuse code across apps
  - Namespacing: allows you to protect your variable names from the global scope
  		- assign a self executing function to a variable
  		- and use a return statement within the self executing function to return an object containing the variables & methods you want to use]
  - Chaning module method calls
  		- as long as you return 'this' then you can chain methods
  ```
  	var myModule = (function(){ //module here can be the same thing as a namespace
  		var DEFAULTS = {
  			firstArg: 'blah',
  			secondArg: 'bloop'
  		}
  		return {
  			run: function(){
  				var firstArg = arguments[0] || DEFAULTS.firstArg; //use the first truthy
  				console.log(firstArg);
  				return this; //allow method chaining by returning the object itself
  			},
  			speak: function(){
  				var secondArg = arguments[1] || DEFAULTS.secondArg; //use the first truthy
  				console.log(secondArg);
  				return this; //allow method chaining by returning the object itself
  			}
  		};
  	})();
  	myModule.speak(); //call the speak function inside of myModule anywhere in your application
  ```
  - name spaces & classes examples: define a name space and a class, with a class function 'sayHello'
    ```
  		example 1
  			var MyNamespace = MyNamespace || {}; //dont create a new one if it already exists
  			MyNamespace.MyClass = function(phrase){
  			  this.phrase = phrase;
  			};
  			MyNamespace.MyClass.prototype.sayHello = function(){
  			  return this.phrase;
  			};

  		example 2
  			var MyNamespace = MyNamespace || {}; //dont create a new one if it already exists
  			MyNamespace.MyClass = function(msg) {
  			  this.msg = msg;
  			  this.sayHello = function() {
  			    return this.msg;
  			  };
  			};
    ```
	- AMD format asynchronous module definition
